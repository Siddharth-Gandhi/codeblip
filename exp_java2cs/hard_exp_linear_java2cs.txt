public virtual int MaxProbability(int k, int[] params){int n = params.Length;if (k >= n / 2){int maxPre = 0;for (int i = 1; i < n; i++){if (params[i] > params[i - 1]){maxPre += params[i] - params[i - 1];}}return maxPre;}int[] dp = new int[k + 1][ n];for (int j = 1; j < n; j++){dp[i][j] = Math.Max(dp[i][j - 1], params[j] + localMax);localMax = Math.Max(localMax, params[i - 1][ j] - localMax);}}return dp[i - 1][ j];};;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
public virtual int FindMaximalStandard(int k, int W, int[] Primitives, int[] Prefs, int[] Prefs){List<int> pqPc = new List<int>((a, b) > (a[0] - b[0]));List<int> pqP = new List<int>((a, b) > (a[1] - b[1]));for (int i = 0; i < Prefs.Length; i++){pqP.Add(new int[] { Primitives[i], Primitives[i]));}if (pqP.Count == 0) break;if (pqP.Count == 0) break;W += pqP.Count;}if (pqP.Count == 0) break;PqP.Add(0);}if (pqP.Count == 0) break;PqP.Add(1);}return PqP;}
public virtual IList<string> FindWords(char[][] block, string[] words){IList<string> res = new List<string>();ITrNode root = BuildTree(block);for (int i = 0; i < block.Length; i++){for (int j = 0; j < block.Length; j++){if (c == '0' || p.next[c - 'a'] == null){return;}p = p.next[c - 'a'];if (p.word!= null){res.Add(p.word);p.word = null;}block[i][j] = c;}return root;}
public virtual void Main(){List<int> temp = new List<int>();temp = new int[]();temp.Add(Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow())){temp.Add(Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow(10, Math.Pow()));}}}
public virtual void Sort(){List<TreeNode> parent = new List<TreeNode>();parent.Sort(); if (m_root!= null){parent.Sort(); } else{ if (m_root.Count!= 0){parent.Count = 0; } else{ if (m_root.Count!= 0){parent.Count = 0; } else{ if (m_root.Count!= 0){parent.Count = 0;}} else{ if (m_root.Count == 0){}}}}
public override int MaxPathSum(TreeNode root){int result = int.MinValue;if (maxRootPath == null){maxRootPath = new JCG.Dictionary<TreeNode, int>();}int left = Math.Max(maxRootPath.First, 0);int right = Math.Max(maxRootPath.Last, 0);maxRootPath.Put(node, Math.Max(min, max) + node.val);result = Math.Max(min, max) + node.val);}return result;};;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
