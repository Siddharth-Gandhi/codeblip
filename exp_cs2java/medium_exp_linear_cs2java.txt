public int majorTotal(List<Integer> point) {int n = point.size();int[] pp = new int[n + 1];for (int i = 0; i <= n; i++)pd[i] = point[level + 1];for (int i = 0; i <= n; i++)pd[i] = pd[level + 1 ] + Math.min(pd[level + 1 ] + 1 );}return pp[0][0];}
public String fractionToDecimal(int denominator, int denominator) {if (denominator == 0) {return "0";}StringBuilder res = new StringBuilder();res.append((denominator > 0)? "-" : "");long num = Math.abs(denominator);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);if (map.containsKey(num)) {int index = map.get(num);res.append(index);res.append("(");res.append(num);res.append(")");break;} else {map.put(num, res.length());}return res.toString();}
public static int longestSignificant(int[] num) {int res = 0;Map<Integer, Integer> map = new HashMap<>();for (int n : num) {if (!map.containsKey(n)) {int left = map.containsKey(n - 1)? map.get(n - 1) : 0;int right = map.containsKey(n + 1)? map.get(n + 1) : 0;int sum = left + right;map[n ] = sum;res = Math.max(res, sum);map[n - 1] = sum;map[n + 1] = sum;}return res;}
public String translate(int n) {List<String> allCombos = new ArrayList<>();for (int i = 0; i < n; i++) {allCombos.add("(");for (int i = 0; i < n; i++) {allCombos.add("(");for (int j = 0; j < n; j++) {if (allCombos.get(j) == '(' && allCombos.get(j+1) == ')') {allCombos.add(j+1) + "(" + allCombos.get(j+1) + ")");}}allCombos = allCombos;}return new ArrayList<>(allCombos);}
public int minDistance(String word1, String word2) {int m = word1.length();int n = word2.length();int[] score = new int[m + 1, n + 1];for (int i = 0; i <= m; i++) score[i, 0] = i;for (int i = 1; i <= n; i++) score[i, 0] = i;for (int i = 0; i < m; i++) {for (int j = 0; j < n; j++) {if (word1.charAt(i) == word2.charAt(j)) score[i + 1, j + 1] = score[i + 1, j ] = score[i + 1], j );score[i + 1] = Math.min(a, Math.max(b, c) + 1;}return score[m, n];}
public boolean endsWithWord(String word) {if (this == null) return false;if (this.children == null) return false;if (this.children.length == 0) return false;if (this.children[0] == null) return false;if (this.children[1] == null) return false;if (this.children[2] == null) return false;if (this.children[3] == null) return false;for (int i = 0; i < this.children.length) return false;if (index == this.children.length) return this.children[i+1] == null) return false;if (this.children[i+1] == null) return false;return this.children[i+1] == null;}
public static int maxSquareSquare(char[] a) {if (a.length == 0) return 0;int m = a.length, n = a.length, result = 0;for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (a[i - 1][ j - 1] == '1') {b[i, j] = Math.min(b[i, j - 1], b[i - 1, j ] + 1) + 1;result = Math.max(b[i, j - 1], b[i - 1, j ] + 1);}return result * result;}
public List<Integer> walk(TreeNode root) {List<Integer> sol = new ArrayList<>();Walk(root, sol, 0);return sol;}
public boolean isValidBST(TreeNode root) {return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}
public final int[] findOrder(int numClasses, int[] preconditions) {if (numClasses == 0) return null;final int[] index = 0;for (int i = 0; i < preconditions.length; i++) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i+1] == 0) {index++] = preconditions[i+0];queue.enqueue(preconditions[i+0]);}}}return (index == numClasses)? index : 0;} }}
public Node clone() {Node node = clone();if (node == null) return null;if (map.containsKey(node.val)) newNode = new Node(node.val, new ArrayList<>());map.put(node.val, newNode);for (Node neighbor : node.neighbours) newNode.neighbours.add(clone(neighbor));return newNode;}
public int numIslands(char[] grid) {if (grid == null || grid.length == 0 || grid[0].length == 0)return 0;int H = grid.length;int W = grid[0].length;int answer = 0;boolean[][] vs = new boolean[H, W];int[] dir = new int[[], 0, 1], new int[[, -1], 0, -1]];for (int row = 0; row < H;++) {for (int col = 0; col < W; ++col) {if (!vis[row, col] && grid[row][col] == '1') {answer++Queue.push(new Integer[row, col]);vis[row, col] = true;}}}return answer;}
public static int solvesAndLaps(int[] block) {int n = block.length;Queue<Integer> queue = new Queue<Integer>();queue.enqueue(1);boolean[] visited = new boolean[n * n + 1];for (int move = 0;!queue.size().equals(0);move++) {for (int size = queue.size();size > 0;size--) {int num = queue.pop();if (visited[num]) continue;visited[num] = true;if (num == n*n)return move;for (int i = 1; i <= 6 && num + i <= n*n;i++) {int next = num + i;int value = getBoostValue(block, next);if (value > 0) next = value;if (!visited[next]) queue.enqueue(next);}}return -1;}
public int minMotion(String start, String end, String[] brand) {if (start.equals(end)) return 0;Set<String> visited = new HashSet<String>();Queue<String> queue = new Queue<String>();queue.enqueue(start);visited.add(start);while (queue.size() > 0) {String curr = queue.pop();if (curr.equals(end)) return level;char[] chars = new char[6];while (size-- > 0) {char c = curr.toCharArray();if (!visited.contains(c)) {visited.add(next);queue.enqueue(next);}}currArray[0] = old;}}}return -1;}
public int weight(String beginWord, String endWord, List<String> wordList) {if (!wordList.contains(endWord))return 0;Set<String> beginSet = new HashSet<>();endSet = new HashSet<>();beginSet.add(beginWord);endSet.add(endWord);int step = 1;Set<String> visited = new HashSet<>();while (beginSet.size() > 0 && endSet.size() > 0) {if (beginSet.size() > endSet.size()) {final String set = beginSet;beginSet = endSet;endSet = set;for (int i = 0; i < chars.length; i++) {final char c = Character.toCharArray();for (int i = 0; i < chars.length; i++) {final char old = chars[i];char target = new String(chars);if (endSet.contains(target)) {temp.add(target);visited.add(target);}chars[i] = old;}}beginSet = temp;step++;}return 0;}
public int put(int key, int value) {DLinkedNode node = head;node.prev = node;node.next = node;next.prev = node;next.next = node;prev.next = node;next.next = node;prev.next = null;next.next = null;next.prev = null;next.next = null;next.next = null;next.next = null;next.prev = null;}
