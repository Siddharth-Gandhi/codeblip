public static int maxProbability(int k, int[] params) {int n = params.length;if (n <= 1) return 0;if (k >= n / 2) {int maxPr = 0;for (int i = 1; i < n; i++) {if (params[i] > params[i - 1]) maxPr += params[i - 1];}return maxPr;}int[] pd = new int[k + 1, n];for (int i = 1; i <= k; i++) {int localMax = pd[i - 1, 0] - params[0];for (int j = 1; j < n; j++) {pd[i, j ] = Math.max(pd[i - 1, j ] + localMax);localMax = Math.max(pd[i - 1, j ] - params[j]);}return pd[k, n - 1];}
public static int findMaximalStandard(int k, int w, int[] p) {List<Integer> projects = new ArrayList<>();for (int i = 0; i < p.getNumberOfPeople(); i++) {projects.add( ((Integer) p.getNumberOfPeople()));i++;}projects.add( (Integer) p.getNumberOfPeople()));i++;if (!availableProviders.isEmpty()) {break;}int maxProbability = availableProviders.orderBy( p => p.getProbability() );maxProbability.remove( maxProbability);}return W;}
public List<String> findWords(char[] block, String[] words) {List<String> res = new ArrayList<>();TrieNode root = buildTree(block);for (int i = 0; i < block.length; i++) {for (int j = 0; j < block.length; j++) {if (p.next[c-1] == null) return;p = p.next[c-1];if (p.next[c] == null) return;p = p.next[c-1];if (p.next[c]!= null) {res.add(p.next[c-1]);}p.next[c] = null;}return root;}
public int calculate(String s) {final int result = 0;final int number = 0;final int sign = 1;for (int i = 0; i < s.length(); i++) {char c = s.charAt(i);if (c == '0') {result += sign * number;number = 0;sign = 1;} else if (c == '+' ) {result += sign * number;number = 0;sign = -1;result = 0;}if (number!= 0 ) result += sign * number;return result;}
public ArrayList<TreeNode> sortBy(TreeNode root) {ArrayList<TreeNode> result = new ArrayList<>();if (root!= null) {ArrayList<TreeNode> stack = new ArrayList<>();stack.add(root);while (stack.size() > 0) {TreeNode cur = stack.getFirst();if (cur.right!= null) stack.add(cur.right);if (cur.left!= null) stack.add(cur.left);return result;}}{}{}{}{}{}{}{}{}{}}}
public int maxPathSum(TreeNode root) {int result = Integer.MAX_VALUE;Map<TreeNode, Integer> maxRootPath = new HashMap<>();maxRootPath[null] = 0;for (TreeNode node : TopSort(root) ) {int left = Math.max(maxRootPath.getValueOrDefault(node.left, 0), 0);int right = Math.max(maxRootPath.getValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.max(maxRootPath.getValue(node.left, 0), 0);maxRootPath[node] = Math.max(maxRootPath.getValue(node.right, 0), 0);return result;}return result;}
