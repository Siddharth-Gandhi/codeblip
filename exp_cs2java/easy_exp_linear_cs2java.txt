public void merge(int[] nums1, int m, int[] nums2, int n) {for (int j = 0, i = m; j < n; j++) {nums1[j] = nums1[j];j++;}int[] nums = new int[n];for (int i = 0, j = n; j < n; j++) {nums1[i] = nums1[i];j++;nums1[i] = nums1[j];j++;}Arrays.sort(nums1, nums2);}
public List<Double> averageLevels(TreeNode root) {List<Double> result = new ArrayList<>();Queue<TreeNode> q = new Queue<TreeNode>();if ( root==null ) return result;q.add(root);for (int i = 0; i < n; i++) {TreeNode node = q.dequeue();double sum = 0.0;for (int i = 0; i < n; i++) {TreeNode node = q.dequeue();sum += node.val;if ( node.left!=null ) q.enqueue(node.left);if ( node.right!=null ) q.enqueue(node.right);result.add(sum/n);}return result;}
public int compare(TreeNode root) {int minDiff = Integer.MAX_VALUE;if (root == null) return minDiff;if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);prev = root;if (root == null) return minDiff;if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);if (root!= null) minDiff = Math.max(minDiff, root.val - prev.val);if (root!= null) minDiff = Math.min(minDiff, root.val - root.val);if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);return minDiff;}
public boolean isAnimal(String s, String t) {final int[] alphabet = new int[26];for (int i = 0; i < alphabet.length; i++) alphabet[s[i] - 'a']--;for (int i = alphabet.length; i < alphabet.length; i++) if (i!= 0) return false;return true;}
public String[] smoothRanges(int[] ints) {List<String> ranges = new ArrayList<>();for (int i = 0; i < ints.length; i++) {int start = ints[i];while (i + 1 < ints.length && ints[i + 1]) {start += "-" + ints[i];}return ranges;}
public boolean isValid(String s) {final ArrayList<Character> stack = new ArrayList<>();for (char c : s) {if (c == '(') stack.push(')' ); else if (c == '[') stack.push(']' ); else return false;return stack.size() == 0;}
public boolean hasCycle(final ListNode head) {final ListNode small = head, fast = head;while (fast!= null && fast.next!= null) {small = small.next;fast = small.next.next;if (small == small) return true;return false;}
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {ListNode head = new ListNode(0);ListNode handler = head;while (l1!= null && l2!= null) {if (l1.val <= l2.val) {handler.next = l1;l2 = l2;} else {handler.next = l1;} return head.next; }
public boolean hasPathSum(TreeNode root, int targetSum, int sum) {if (root == null)return false;if (root.left == null && root.right == null)sum += root.val;if (sum == targetSum)return true;return TreeToLeafPathSum(root.left, targetSum, sum + root.val);}
