public void merge(int[] nums1, int m, int[] nums2, int n) {for (int j = 0, i = m; j < n; j++) {nums1[j] = nums1[j];j++;}int[] nums = new int[n];for (int i = 0, j = n; j < n; j++) {nums1[i] = nums1[i];j++;nums1[i] = nums1[j];j++;}Arrays.sort(nums1, nums2);}
public int majorTotal(List<Integer> point) {int n = point.size();int[] pp = new int[n + 1];for (int i = 0; i <= n; i++)pd[i] = point[level + 1];for (int i = 0; i <= n; i++)pd[i] = pd[level + 1 ] + Math.min(pd[level + 1 ] + 1 );}return pp[0][0];}
public static int maxProbability(int k, int[] params) {int n = params.length;if (n <= 1) return 0;if (k >= n / 2) {int maxPr = 0;for (int i = 1; i < n; i++) {if (params[i] > params[i - 1]) maxPr += params[i - 1];}return maxPr;}int[] pd = new int[k + 1, n];for (int i = 1; i <= k; i++) {int localMax = pd[i - 1, 0] - params[0];for (int j = 1; j < n; j++) {pd[i, j ] = Math.max(pd[i - 1, j ] + localMax);localMax = Math.max(pd[i - 1, j ] - params[j]);}return pd[k, n - 1];}
public String fractionToDecimal(int denominator, int denominator) {if (denominator == 0) {return "0";}StringBuilder res = new StringBuilder();res.append((denominator > 0)? "-" : "");long num = Math.abs(denominator);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);res.append(num);if (map.containsKey(num)) {int index = map.get(num);res.append(index);res.append("(");res.append(num);res.append(")");break;} else {map.put(num, res.length());}return res.toString();}
public static int longestSignificant(int[] num) {int res = 0;Map<Integer, Integer> map = new HashMap<>();for (int n : num) {if (!map.containsKey(n)) {int left = map.containsKey(n - 1)? map.get(n - 1) : 0;int right = map.containsKey(n + 1)? map.get(n + 1) : 0;int sum = left + right;map[n ] = sum;res = Math.max(res, sum);map[n - 1] = sum;map[n + 1] = sum;}return res;}
public static int findMaximalStandard(int k, int w, int[] p) {List<Integer> projects = new ArrayList<>();for (int i = 0; i < p.getNumberOfPeople(); i++) {projects.add( ((Integer) p.getNumberOfPeople()));i++;}projects.add( (Integer) p.getNumberOfPeople()));i++;if (!availableProviders.isEmpty()) {break;}int maxProbability = availableProviders.orderBy( p => p.getProbability() );maxProbability.remove( maxProbability);}return W;}
public String translate(int n) {List<String> allCombos = new ArrayList<>();for (int i = 0; i < n; i++) {allCombos.add("(");for (int i = 0; i < n; i++) {allCombos.add("(");for (int j = 0; j < n; j++) {if (allCombos.get(j) == '(' && allCombos.get(j+1) == ')') {allCombos.add(j+1) + "(" + allCombos.get(j+1) + ")");}}allCombos = allCombos;}return new ArrayList<>(allCombos);}
public int minDistance(String word1, String word2) {int m = word1.length();int n = word2.length();int[] score = new int[m + 1, n + 1];for (int i = 0; i <= m; i++) score[i, 0] = i;for (int i = 1; i <= n; i++) score[i, 0] = i;for (int i = 0; i < m; i++) {for (int j = 0; j < n; j++) {if (word1.charAt(i) == word2.charAt(j)) score[i + 1, j + 1] = score[i + 1, j ] = score[i + 1], j );score[i + 1] = Math.min(a, Math.max(b, c) + 1;}return score[m, n];}
public static int maxSquareSquare(char[] a) {if (a.length == 0) return 0;int m = a.length, n = a.length, result = 0;for (int i = 1; i <= m; i++) {for (int j = 1; j <= n; j++) {if (a[i - 1][ j - 1] == '1') {b[i, j] = Math.min(b[i, j - 1], b[i - 1, j ] + 1) + 1;result = Math.max(b[i, j - 1], b[i - 1, j ] + 1);}return result * result;}
public List<Double> averageLevels(TreeNode root) {List<Double> result = new ArrayList<>();Queue<TreeNode> q = new Queue<TreeNode>();if ( root==null ) return result;q.add(root);for (int i = 0; i < n; i++) {TreeNode node = q.dequeue();double sum = 0.0;for (int i = 0; i < n; i++) {TreeNode node = q.dequeue();sum += node.val;if ( node.left!=null ) q.enqueue(node.left);if ( node.right!=null ) q.enqueue(node.right);result.add(sum/n);}return result;}
public final int[] findOrder(int numClasses, int[] preconditions) {if (numClasses == 0) return null;final int[] index = 0;for (int i = 0; i < preconditions.length; i++) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i] == 0) {index++;if (preconditions[i+1] == 0) {index++] = preconditions[i+0];queue.enqueue(preconditions[i+0]);}}}return (index == numClasses)? index : 0;} }}
public int numIslands(char[] grid) {if (grid == null || grid.length == 0 || grid[0].length == 0)return 0;int H = grid.length;int W = grid[0].length;int answer = 0;boolean[][] vs = new boolean[H, W];int[] dir = new int[[], 0, 1], new int[[, -1], 0, -1]];for (int row = 0; row < H;++) {for (int col = 0; col < W; ++col) {if (!vis[row, col] && grid[row][col] == '1') {answer++Queue.push(new Integer[row, col]);vis[row, col] = true;}}}return answer;}
public int minMotion(String start, String end, String[] brand) {if (start.equals(end)) return 0;Set<String> visited = new HashSet<String>();Queue<String> queue = new Queue<String>();queue.enqueue(start);visited.add(start);while (queue.size() > 0) {String curr = queue.pop();if (curr.equals(end)) return level;char[] chars = new char[6];while (size-- > 0) {char c = curr.toCharArray();if (!visited.contains(c)) {visited.add(next);queue.enqueue(next);}}currArray[0] = old;}}}return -1;}
public int weight(String beginWord, String endWord, List<String> wordList) {if (!wordList.contains(endWord))return 0;Set<String> beginSet = new HashSet<>();endSet = new HashSet<>();beginSet.add(beginWord);endSet.add(endWord);int step = 1;Set<String> visited = new HashSet<>();while (beginSet.size() > 0 && endSet.size() > 0) {if (beginSet.size() > endSet.size()) {final String set = beginSet;beginSet = endSet;endSet = set;for (int i = 0; i < chars.length; i++) {final char c = Character.toCharArray();for (int i = 0; i < chars.length; i++) {final char old = chars[i];char target = new String(chars);if (endSet.contains(target)) {temp.add(target);visited.add(target);}chars[i] = old;}}beginSet = temp;step++;}return 0;}
public int calculate(String s) {final int result = 0;final int number = 0;final int sign = 1;for (int i = 0; i < s.length(); i++) {char c = s.charAt(i);if (c == '0') {result += sign * number;number = 0;sign = 1;} else if (c == '+' ) {result += sign * number;number = 0;sign = -1;result = 0;}if (number!= 0 ) result += sign * number;return result;}
public boolean isAnimal(String s, String t) {final int[] alphabet = new int[26];for (int i = 0; i < alphabet.length; i++) alphabet[s[i] - 'a']--;for (int i = alphabet.length; i < alphabet.length; i++) if (i!= 0) return false;return true;}
public String[] smoothRanges(int[] ints) {List<String> ranges = new ArrayList<>();for (int i = 0; i < ints.length; i++) {int start = ints[i];while (i + 1 < ints.length && ints[i + 1]) {start += "-" + ints[i];}return ranges;}
public boolean isValid(String s) {final ArrayList<Character> stack = new ArrayList<>();for (char c : s) {if (c == '(') stack.push(')' ); else if (c == '[') stack.push(']' ); else return false;return stack.size() == 0;}
public boolean hasCycle(final ListNode head) {final ListNode small = head, fast = head;while (fast!= null && fast.next!= null) {small = small.next;fast = small.next.next;if (small == small) return true;return false;}
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {ListNode head = new ListNode(0);ListNode handler = head;while (l1!= null && l2!= null) {if (l1.val <= l2.val) {handler.next = l1;l2 = l2;} else {handler.next = l1;} return head.next; }
public ArrayList<TreeNode> sortBy(TreeNode root) {ArrayList<TreeNode> result = new ArrayList<>();if (root!= null) {ArrayList<TreeNode> stack = new ArrayList<>();stack.add(root);while (stack.size() > 0) {TreeNode cur = stack.getFirst();if (cur.right!= null) stack.add(cur.right);if (cur.left!= null) stack.add(cur.left);return result;}}{}{}{}{}{}{}{}{}{}}}
public int maxPathSum(TreeNode root) {int result = Integer.MAX_VALUE;Map<TreeNode, Integer> maxRootPath = new HashMap<>();maxRootPath[null] = 0;for (TreeNode node : TopSort(root) ) {int left = Math.max(maxRootPath.getValueOrDefault(node.left, 0), 0);int right = Math.max(maxRootPath.getValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.max(maxRootPath.getValue(node.left, 0), 0);maxRootPath[node] = Math.max(maxRootPath.getValue(node.right, 0), 0);return result;}return result;}
