public List<String> findWords(char[] block, String[] words) {List<String> res = new ArrayList<>();TrieNode root = buildTree(block);for (int i = 0; i < block.length; i++) {for (int j = 0; j < block.length; j++) {if (p.next[c-1] == null) return;p = p.next[c-1];if (p.next[c] == null) return;p = p.next[c-1];if (p.next[c]!= null) {res.add(p.next[c-1]);}p.next[c] = null;}return root;}
public boolean endsWithWord(String word) {if (this == null) return false;if (this.children == null) return false;if (this.children.length == 0) return false;if (this.children[0] == null) return false;if (this.children[1] == null) return false;if (this.children[2] == null) return false;if (this.children[3] == null) return false;for (int i = 0; i < this.children.length) return false;if (index == this.children.length) return this.children[i+1] == null) return false;if (this.children[i+1] == null) return false;return this.children[i+1] == null;}
public List<Integer> walk(TreeNode root) {List<Integer> sol = new ArrayList<>();Walk(root, sol, 0);return sol;}
public boolean isValidBST(TreeNode root) {return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}
public int compare(TreeNode root) {int minDiff = Integer.MAX_VALUE;if (root == null) return minDiff;if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);prev = root;if (root == null) return minDiff;if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);if (root!= null) minDiff = Math.max(minDiff, root.val - prev.val);if (root!= null) minDiff = Math.min(minDiff, root.val - root.val);if (prev!= null) minDiff = Math.min(minDiff, root.val - prev.val);return minDiff;}
public Node clone() {Node node = clone();if (node == null) return null;if (map.containsKey(node.val)) newNode = new Node(node.val, new ArrayList<>());map.put(node.val, newNode);for (Node neighbor : node.neighbours) newNode.neighbours.add(clone(neighbor));return newNode;}
public static int solvesAndLaps(int[] block) {int n = block.length;Queue<Integer> queue = new Queue<Integer>();queue.enqueue(1);boolean[] visited = new boolean[n * n + 1];for (int move = 0;!queue.size().equals(0);move++) {for (int size = queue.size();size > 0;size--) {int num = queue.pop();if (visited[num]) continue;visited[num] = true;if (num == n*n)return move;for (int i = 1; i <= 6 && num + i <= n*n;i++) {int next = num + i;int value = getBoostValue(block, next);if (value > 0) next = value;if (!visited[next]) queue.enqueue(next);}}return -1;}
public int put(int key, int value) {DLinkedNode node = head;node.prev = node;node.next = node;next.prev = node;next.next = node;prev.next = node;next.next = node;prev.next = null;next.next = null;next.prev = null;next.next = null;next.next = null;next.next = null;next.prev = null;}
public boolean hasPathSum(TreeNode root, int targetSum, int sum) {if (root == null)return false;if (root.left == null && root.right == null)sum += root.val;if (sum == targetSum)return true;return TreeToLeafPathSum(root.left, targetSum, sum + root.val);}
