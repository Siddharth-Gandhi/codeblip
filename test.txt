public boolean hasCycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.next != null){slow = slow.next;fast = fast.next.next;if(slow == fast) return true;}return false;}
public int snakesAndLadders(int[][] board){int n = board.length;Queue<Integer> queue = new LinkedList<>();queue.offer(1);boolean[] visited = new boolean[n * n + 1];for(int move = 0;!queue.isEmpty();move++){for(int size = queue.size();size > 0;size--){int num = queue.poll();if(visited[num]) continue;visited[num] = true;if(num == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n;i++){int next = num + i;int value = getBoardValue(board, next);if(value > 0) next = value;if(!visited[next]) queue.offer(next);}}}return -1;}private int getBoardValue(int[][] board, int num){int n = board.length;int r =(num - 1) / n;int x = n - 1 - r;int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;return board[x][y];}
public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) ->(a[0] - b[0]));PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) ->(b[1] - a[1]));for(int i = 0;i < Profits.length;i++){pqCap.add(new int[]{Capital[i], Profits[i]});}for(int i = 0;i < k;i++){while(!pqCap.isEmpty() && pqCap.peek()[0] <= W){pqPro.add(pqCap.poll());}if(pqPro.isEmpty()) break;W += pqPro.poll()[1];}return W;}