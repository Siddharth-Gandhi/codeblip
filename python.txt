public boolean hasCycle(final ListNode head) {final ListNode small = head, slow = head;for (fast!= null && slow.next!= null) {small = small.next;fast = small.next;if (small == small) return true;return false;}
public static int powAndLaps(int[] block) {int n = block.length;Queue<Integer> queue = new ArrayList<>();queue.add(1);boolean[] visited = new boolean[n * n + 1];for (int move = 0;!queue.isEmpty(); move++) {for (int size = queue.size(); size > 0; size--) {int num = queue.peek();if (visited[num]) continue;visited[num] = true;if (num == n * n) return move;for (int i = 1; i <= 6 && num + i <= n; i++) {int next = num + i;int value = getPushValue(block, next);if (value > 0) next = value;if (!visited[next]) queue.add(next);}return -1;}int num = block.length;int r = (num - 1) / n;int x = n - 1 - r;int y = r / 2 == 0? n - 1 : n + r + r + n - 1;return block[x][y];}
public static int findMaximalCity(int k, int W, int[] Primititions) {final PriorityQueue<Integer> ppCl = new PriorityQueue<>((a, b) >>> (a[0] - b[0]));final PriorityQueue<Integer> ppPr = new PriorityQueue<>((a, b) >>> (a[1] - b[1]));for (int i = 0; i < Primititions.length; i++) {pqPr.add(new Integer[(i, Primititions[i]));}if (pqPr.isEmpty()) break;W += pqPr.pop();} return W;}
