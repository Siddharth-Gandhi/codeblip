public void Merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Array.Sort(nums1);}
public int MinimumTotal(IList<IList<int>> triangle){int n = triangle.Count;int[][] dp = new int[n + 1][];for(int i = 0;i <= n;i++){dp[i] = new int[n + 1];}for(int level = n - 1;level >= 0;level--){for(int i = 0;i <= level;i++){dp[level][i] = triangle[level][i] + Math.Min(dp[level + 1][i], dp[level + 1][i + 1]);}}return dp[0][0];}
public int MaxProfit(int k, int[] prices){int n = prices.Length;if(n <= 1) return 0;if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(prices[i] > prices[i - 1]) maxPro += prices[i] - prices[i - 1];}return maxPro;}int[,] dp = new int[k + 1, n];for(int i = 1;i <= k;i++){int localMax = dp[i - 1, 0] - prices[0];for(int j = 1;j < n;j++){dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax);localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]);}}return dp[k, n - 1];}
public string FractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.Append((numerator > 0) ^(denominator > 0) ? "-" : "");long num = System.Math.Abs((long)numerator);long den = System.Math.Abs((long)denominator);res.Append(num / den);num %= den;if(num == 0){return res.ToString();}res.Append(".");Dictionary<long, int> map = new Dictionary<long, int>();map.Add(num, res.Length);while(num != 0){num *= 10;res.Append(num / den);num %= den;if(map.ContainsKey(num)){int index = map[num];res.Insert(index, "(");res.Append(")");break;}else{map.Add(num, res.Length);}}return res.ToString();}
public int LongestConsecutive(int[] num){int res = 0;Dictionary<int, int> map = new Dictionary<int, int>();foreach(int n in num){if(!map.ContainsKey(n)){int left = map.ContainsKey(n - 1) ? map[n - 1] : 0;int right = map.ContainsKey(n + 1) ? map[n + 1] : 0;int sum = left + right + 1;map[n] = sum;res = System.Math.Max(res, sum);map[n - left] = sum;map[n + right] = sum;}}return res;}
public int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital){List<(int Capital, int Profit)> projects = new List<(int Capital, int Profit)>();for(int i = 0;i < Profits.Length;i++){projects.Add((Capital[i], Profits[i]));}projects = projects.OrderBy(p => p.Capital).ToList();List<(int Capital, int Profit)> availableProjects = new List<(int Capital, int Profit)>();int index = 0;for(int i = 0;i < k;i++){while(index < projects.Count && projects[index].Capital <= W){availableProjects.Add(projects[index]);index++;}if(!availableProjects.Any()) break;var maxProfitProject = availableProjects.OrderByDescending(p => p.Profit).First();W += maxProfitProject.Profit;availableProjects.Remove(maxProfitProject);}return W;}
public IList<string> GenerateParenthesis(int n){HashSet<string> allCombos = new HashSet<string>();for(int i = 0;i < n;i++){if(allCombos.Count == 0){allCombos.Add("()");}else{HashSet<string> combos = new HashSet<string>();foreach(string combo in allCombos){combos.Add(combo + "()");combos.Add("()" + combo);for(int j = 0;j < combo.Length - 1;j++){if(combo[j] == '(' && combo[j + 1] == ')'){combos.Add(combo.Substring(0, j + 1) + "()" + combo.Substring(j + 1));combos.Add(combo.Substring(0, j + 1) + ")(" + combo.Substring(j + 1));}}}allCombos = combos;}}return new List<string>(allCombos);}
public class Solution{public IList<string> FindWords(char[][] board, string[] words){List<string> res = new List<string>();TrieNode root = BuildTrie(words);for(int i = 0;i < board.Length;i++){for(int j = 0;j < board[0].Length;j++){Dfs(board, i, j, root, res);}}return res;}public void Dfs(char[][] board, int i, int j, TrieNode p, List<string> res){char c = board[i][j];if(c == '#' || p.Next[c - 'a'] == null) return;p = p.Next[c - 'a'];if(p.Word != null){res.Add(p.Word);p.Word = null;}board[i][j] = '#';if(i > 0) Dfs(board, i - 1, j, p, res);if(j > 0) Dfs(board, i, j - 1, p, res);if(i < board.Length - 1) Dfs(board, i + 1, j, p, res);if(j < board[0].Length - 1) Dfs(board, i, j + 1, p, res);board[i][j] = c;}public TrieNode BuildTrie(string[] words){TrieNode root = new TrieNode();foreach(string w in words){TrieNode p = root;foreach(char c in w){int i = c - 'a';if(p.Next[i] == null) p.Next[i] = new TrieNode();p = p.Next[i];}p.Word = w;}return root;}}public class TrieNode{public TrieNode[] Next = new TrieNode[26];public string Word;}
public int MinDistance(string word1, string word2){int m = word1.Length;int n = word2.Length;int[,] cost = new int[m + 1, n + 1];for(int i = 0;i <= m;i++) cost[i, 0] = i;for(int i = 1;i <= n;i++) cost[0, i] = i;for(int i = 0;i < m;i++){for(int j = 0;j < n;j++){if(word1[i] == word2[j]) cost[i + 1, j + 1] = cost[i, j];else{int a = cost[i, j];int b = cost[i, j + 1];int c = cost[i + 1, j];cost[i + 1, j + 1] = Math.Min(a, Math.Min(b, c)) + 1;}}}return cost[m, n];}
public class WordDictionary{private WordDictionary[] children;private bool isEndOfWord;public WordDictionary(){children = new WordDictionary[26];isEndOfWord = false;}public void AddWord(string word){WordDictionary curr = this;foreach(char c in word){if(curr.children[c - 'a'] == null) curr.children[c - 'a'] = new WordDictionary();curr = curr.children[c - 'a'];}curr.isEndOfWord = true;}public bool Search(string word){return Search(word, 0, this);}private bool Search(string word, int index, WordDictionary node){if(node == null) return false;if(index == word.Length) return node.isEndOfWord;char c = word[index];if(c == '.'){foreach(WordDictionary child in node.children){if(child != null && Search(word, index + 1, child)) return true;}return false;}else{return Search(word, index + 1, node.children[c - 'a']);}}}
public int MaximalSquare(char[][] a){if(a.Length == 0) return 0;int m = a.Length, n = a[0].Length, result = 0;int[,] b = new int[m + 1, n + 1];for(int i = 1;i <= m;i++){for(int j = 1;j <= n;j++){if(a[i - 1][j - 1] == '1'){b[i, j] = Math.Min(Math.Min(b[i, j - 1], b[i - 1, j - 1]), b[i - 1, j]) + 1;result = Math.Max(b[i, j], result);}}}return result * result;}
public class Solution{public IList<IList<int>> ZigzagLevelOrder(TreeNode root){IList<IList<int>> sol = new List<IList<int>>();Travel(root, sol, 0);return sol;}private void Travel(TreeNode curr, IList<IList<int>> sol, int level){if(curr == null) return;if(sol.Count <= level){IList<int> newLevel = new List<int>();sol.Add(newLevel);}IList<int> collection = sol[level];if(level % 2 == 0) collection.Add(curr.val);else collection.Insert(0, curr.val);Travel(curr.left, sol, level + 1);Travel(curr.right, sol, level + 1);}}
public IList<double> AverageOfLevels(TreeNode root){List<double> result = new List<double>();Queue<TreeNode> q = new Queue<TreeNode>();if(root == null) return result;q.Enqueue(root);while(q.Count > 0){int n = q.Count;double sum = 0.0;for(int i = 0;i < n;i++){TreeNode node = q.Dequeue();sum += node.val;if(node.left != null) q.Enqueue(node.left);if(node.right != null) q.Enqueue(node.right);}result.Add(sum / n);}return result;}
public class Solution{public bool IsValidBST(TreeNode root){return IsValidBST(root, long.MinValue, long.MaxValue);}public bool IsValidBST(TreeNode root, long minVal, long maxVal){if(root == null) return true;if(root.val >= maxVal || root.val <= minVal) return false;return IsValidBST(root.left, minVal, root.val) && IsValidBST(root.right, root.val, maxVal);}}
public int[] FindOrder(int numCourses, int[][] prerequisites){if(numCourses == 0) return null;int[] indegree = new int[numCourses], order = new int[numCourses];int index = 0;for(int i = 0;i < prerequisites.Length;i++) indegree[prerequisites[i][0]]++;Queue<int> queue = new Queue<int>();for(int i = 0;i < numCourses;i++) if(indegree[i] == 0){order[index++] = i;queue.Enqueue(i);}while(queue.Count > 0){int prerequisite = queue.Dequeue();for(int i = 0;i < prerequisites.Length;i++){if(prerequisites[i][1] == prerequisite){indegree[prerequisites[i][0]]--;if(indegree[prerequisites[i][0]] == 0){order[index++] = prerequisites[i][0];queue.Enqueue(prerequisites[i][0]);}}}}return(index == numCourses) ? order : new int[0];}
public class Solution{int minDiff = int.MaxValue;TreeNode prev;public int GetMinimumDifference(TreeNode root){Inorder(root);return minDiff;}public void Inorder(TreeNode root){if(root == null) return;Inorder(root.left);if(prev != null) minDiff = Math.Min(minDiff, root.val - prev.val);prev = root;Inorder(root.right);}}
public class Solution{private Dictionary<int, Node> map = new Dictionary<int, Node>();public Node CloneGraph(Node node){return Clone(node);}private Node Clone(Node node){if(node == null) return null;if(map.ContainsKey(node.val)) return map[node.val];Node newNode = new Node(node.val, new List<Node>());map.Add(newNode.val, newNode);foreach(Node neighbor in node.neighbors) newNode.neighbors.Add(Clone(neighbor));return newNode;}}
public int NumIslands(char[][] grid){if(grid == null || grid.Length == 0 || grid[0].Length == 0){return 0;}int H = grid.Length;int W = grid[0].Length;int answer = 0;bool[,] vis = new bool[H, W];int[][] directions = new int[][]{new int[]{1, 0}, new int[]{0, 1}, new int[]{-1, 0}, new int[]{0, -1}};for(int row = 0;row < H;++row){for(int col = 0;col < W;++col){if(!vis[row, col] && grid[row][col] == '1'){answer++;Queue<int[]> q = new Queue<int[]>();q.Enqueue(new int[]{row, col});vis[row, col] = true;while(q.Count > 0){int[] p = q.Dequeue();foreach(int[] dir in directions){int newRow = p[0] + dir[0];int newCol = p[1] + dir[1];if(newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !vis[newRow, newCol] && grid[newRow][newCol] == '1'){q.Enqueue(new int[]{newRow, newCol});vis[newRow, newCol] = true;}}}}}}return answer;}
public int SnakesAndLadders(int[][] board){int n = board.Length;Queue<int> queue = new Queue<int>();queue.Enqueue(1);bool[] visited = new bool[n * n + 1];for(int move = 0;!queue.Count.Equals(0);move++){for(int size = queue.Count;size > 0;size--){int num = queue.Dequeue();if(visited[num]) continue;visited[num] = true;if(num == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n;i++){int next = num + i;int value = GetBoardValue(board, next);if(value > 0) next = value;if(!visited[next]) queue.Enqueue(next);}}}return -1;}private int GetBoardValue(int[][] board, int num){int n = board.Length;int r =(num - 1) / n;int x = n - 1 - r;int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;return board[x][y];}
public int MinMutation(string start, string end, string[] bank){if(start.Equals(end)) return 0;HashSet<string> bankSet = new HashSet<string>(bank);char[] charSet = new char[]{'A', 'C', 'G', 'T'};int level = 0;HashSet<string> visited = new HashSet<string>();Queue<string> queue = new Queue<string>();queue.Enqueue(start);visited.Add(start);while(queue.Count > 0){int size = queue.Count;while(size-- > 0){string curr = queue.Dequeue();if(curr.Equals(end)) return level;char[] currArray = curr.ToCharArray();for(int i = 0;i < currArray.Length;i++){char old = currArray[i];foreach(char c in charSet){currArray[i] = c;string next = new string(currArray);if(!visited.Contains(next) && bankSet.Contains(next)){visited.Add(next);queue.Enqueue(next);}}currArray[i] = old;}}level++;}return -1;}
public int LadderLength(string beginWord, string endWord, IList<string> wordList){if(!wordList.Contains(endWord)){return 0;}HashSet<string> dict = new HashSet<string>(wordList);HashSet<string> beginSet = new HashSet<string>(), endSet = new HashSet<string>();beginSet.Add(beginWord);endSet.Add(endWord);int step = 1;HashSet<string> visited = new HashSet<string>();while(beginSet.Count > 0 && endSet.Count > 0){if(beginSet.Count > endSet.Count){var set = beginSet;beginSet = endSet;endSet = set;}HashSet<string> temp = new HashSet<string>();foreach(string word in beginSet){char[] chs = word.ToCharArray();for(int i = 0;i < chs.Length;i++){for(char c = 'a';c <= 'z';c++){char old = chs[i];chs[i] = c;string target = new string(chs);if(endSet.Contains(target)){return step + 1;}if(!visited.Contains(target) && dict.Contains(target)){temp.Add(target);visited.Add(target);}chs[i] = old;}}}beginSet = temp;step++;}return 0;}
public int Calculate(string s){Stack<int> stack = new Stack<int>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.Length;i++){char c = s[i];if(char.IsDigit(c)){number = 10 * number +(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '('){stack.Push(result);stack.Push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.Pop();result += stack.Pop();}}if(number != 0) result += sign * number;return result;}
public bool IsAnagram(string s, string t){int[] alphabet = new int[26];for(int i = 0;i < s.Length;i++) alphabet[s[i] - 'a']++;for(int i = 0;i < t.Length;i++) alphabet[t[i] - 'a']--;foreach(int i in alphabet) if(i != 0) return false;return true;}
public List<string> SummaryRanges(int[] nums){List<string> ranges = new List<string>();for(int i = 0;i < nums.Length;i++){int start = nums[i];while(i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]){i++;}if(start != nums[i]){ranges.Add(start + "->" + nums[i]);}else{ranges.Add(start.ToString());}}return ranges;}
public bool IsValid(string s){Stack<char> stack = new Stack<char>();foreach(char c in s){if(c == '(') stack.Push(')');else if(c == '{') stack.Push('}');else if(c == '[') stack.Push(']');else if(stack.Count == 0 || stack.Pop() != c) return false;}return stack.Count == 0;}
public bool HasCycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.next != null){slow = slow.next;fast = fast.next.next;if(slow == fast) return true;}return false;}
public ListNode MergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNode handler = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handler.next = l1;l1 = l1.next;}else{handler.next = l2;l2 = l2.next;}handler = handler.next;}if(l1 != null){handler.next = l1;}else if(l2 != null){handler.next = l2;}return head.next;}
public class LRUCache{class DLinkedNode{public int key;public int value;public DLinkedNode prev;public DLinkedNode next;}private void AddNode(DLinkedNode node){node.prev = head;node.next = head.next;head.next.prev = node;head.next = node;}private void RemoveNode(DLinkedNode node){DLinkedNode prev = node.prev;DLinkedNode next = node.next;prev.next = next;next.prev = prev;}private void MoveToHead(DLinkedNode node){RemoveNode(node);AddNode(node);}private DLinkedNode PopTail(){DLinkedNode res = tail.prev;RemoveNode(res);return res;}private Dictionary<int, DLinkedNode> cache = new Dictionary<int, DLinkedNode>();private int count;private int capacity;private DLinkedNode head, tail;public LRUCache(int capacity){this.count = 0;this.capacity = capacity;head = new DLinkedNode();head.prev = null;tail = new DLinkedNode();tail.next = null;head.next = tail;tail.prev = head;}public int Get(int key){if(!cache.ContainsKey(key)){return -1;}DLinkedNode node = cache[key];MoveToHead(node);return node.value;}public void Put(int key, int value){if(!cache.ContainsKey(key)){DLinkedNode newNode = new DLinkedNode();newNode.key = key;newNode.value = value;cache[key] = newNode;AddNode(newNode);++count;if(count > capacity){DLinkedNode tail = PopTail();cache.Remove(tail.key);--count;}}else{DLinkedNode node = cache[key];node.value = value;MoveToHead(node);}}}
public class Solution{public bool RootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null) return false;if(root.left == null && root.right == null){sum += root.val;if(sum == targetSum) return true;}return RootToLeafPathSum(root.left, targetSum, sum + root.val) || RootToLeafPathSum(root.right, targetSum, sum + root.val);}public bool HasPathSum(TreeNode root, int targetSum){int sum = 0;return RootToLeafPathSum(root, targetSum, sum);}}
public IEnumerable<TreeNode> TopSort(TreeNode root){LinkedList<TreeNode> result = new LinkedList<TreeNode>();if(root != null){LinkedList<TreeNode> stack = new LinkedList<TreeNode>();stack.AddFirst(root);while(stack.Count > 0){TreeNode curr = stack.First.Value;stack.RemoveFirst();result.AddFirst(curr);if(curr.right != null) stack.AddFirst(curr.right);if(curr.left != null) stack.AddFirst(curr.left);}}return result;}
public int MaxPathSum(TreeNode root){int result = int.MinValue;Dictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode, int>();maxRootPath[null] = 0;foreach(TreeNode node in TopSort(root)){int left = Math.Max(maxRootPath.GetValueOrDefault(node.left, 0), 0);int right = Math.Max(maxRootPath.GetValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.Max(left, right) + node.val;result = Math.Max(left + right + node.val, result);}return result;}
