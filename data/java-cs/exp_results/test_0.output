public virtual void Merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Arrays.Sort(nums1);}
public int MinimumTotal(IList<int> tracker){int n = trile.Count;int[][] dp = new int[n + 1][n + 1];for(int i = n - 1;level >= 0;level--){for(int i = 0;i <= level;i++){dp[i] =((int)(dp[i) + Math.Min(dp[i] + 1].Pow(dp[level + 1], dp[level + 1].[i + 1]);}return dp[0].[0];}
public virtual int MaxProfit(int k, int[] properties){int n = prices.Length;if(n <= 1)return 0;if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(props[i] > properties[i - 1]){maxPro += prices[i] - 1];}}return maxPro;}int[][] dp = new int[k + 1][];for(int i = 1;i <= k;i++){int localMax = dp[i - 1].[0] - records[0];for(int j = 1;j < n;j++){dp[i] = Math.Max(df, dp[i - 1], properties[j] + localMax);localMax = Math.Max(localMax, dp[i - 1].Max);}}return dp[k][n - 1];}
public virtual stringractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.Append((numerator > 0) ^(denominator > 0)) ? "-" : string.Empty);long num = Math.Abs((long)numerator);long num = Math.Abs((long)denominator);res.Append(num / n);num %= num;if(num == 0){return res.ToString();}res.Append(".");Dictionary<long, int> map = new Dictionary<long, int>();map[num] = new Dictionary<long, int>();while(num != 0){num *= 10;res.Append(num / den);num %=den;if(map.ContainsKey(num)){int index = map[num];res.Insert(index, "(");res.Append(")");break;}else{map[num] = res.Length;}}return res.ToString();}
public virtual int longestConsecutive(int[] num){int res = 0;Dictionary<int, int> map = new Dictionary<int, int>();foreach(int n in num){if(!map.ContainsKey(n)){int left =(map.ContainsKey(n - 1)) ? map[n - 1] : 0;int right =(map.ContainsKey(n + 1) ? map[n + 1] : 0;int sum = left + right + 1;map[n] = sum;map[n - left] = sum;map[n - left] = sum;}else{continue;}}return res;}
public virtual int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital){PriorityQueue<int[]> pqCap = new PrefixList<int>((a, b) =>(a[0] - b[0]));ParerQueue<int[] pqPro = new PrefixQueue((a, b) - a[1]));for(int i = 0;i < Profits.Length;i++){pqCap.Add(new int[]{Capital[i], Profits[i]};}for(int i = 0;i < k;i++){while(!pqCap.Count && pqCap.Peek()[0] <= W){pqPro.Add(pqCap());}if(pqPro.Count == 0){break;}W += pqPro.Poll();}return W;}
public virtual IList<string> GenerateParenthesis(int n){HashSet<string> allCombos = new HashSet<string>();for(int i = 0;i < n;i++){if(allCombos.Count == 0){allCombos.Add("()");}else{java.util.HashSet<string> combos = new JCG.HashSet<string>();foreach(string combo in allCombos){comparison.Add(comparison.Create()");comparison.Add("()", composer);for(int j = 0;j < composer.Length - 1;j++){if(comcomparison.CharAt(comparison.Substring(0, j + 1) == '){merged.Add(comparison.Substring(0, j + 1));merged.Add(comparison.Substring(0, j + 1));}}allCombos = combos;}}return new List<string>(allCombos);}
public virtual IList<string> FindWords(char[][] tab, string[] words){IList<string> res = new List<string>();TrieNode root = BuildTrie(words);for(int i = 0;i < BO.Length;i++){for(int j = 0;j < row.Length;j++){Dfs(old, i, j, root, res);}}return res;}
public virtual int MinDistance(string word1, string word2){int m = word1.Length;int n = word2.Length;int[][] cost = new int[m + 1][n + 1];for(int i = 0;i <= m;i++){cost[i] = i;}for(int i = 1;i <= n;i++){costs[i] = i;}for(int i = 0;i < n;i++){if(word1[i] == word2[j]){costs[i + 1] = cost[i];}else{int a = cost[i][j];int b = cost[i][j];int c = cost[i + 1];int c = cost[i + 1];int c = cost[i + 1];cost[i + 1] = a < b ?(a < c ? a : c) :(b < c ? b : c);costs[i + 1]++;}}return cost[m][m];}
public WordDictionary<string> children;bool isEndOfWord;children = false;}
public virtual int maximalSquare(char[][] a){if(a.Length == 0){return 0;}int m = a.Length, n = a[0].Length, result = 0;int[][] b = new int[m + 1][m + 1];for(int i = 1;i <= m;i++){for(int j = 1;j <= n;j++){if(a[i - 1] == '1'){b[j] = Math.Min(Math.Min(b[j - 1], b[i - 1]) + 1;result = Math.Max(b[i][j], result);}}return result * result;}
public virtual IList<IList<int> ZigzagLevelOrder(TreeNode root){IList<List<int> sol = new List<int>();Transport(root, first, 0);return left;}Private;}
public virtual IList<double> AverageOfLevels(TreeNode root){IList<double> result = new List<double>();Queue<TreeNode> q = new List<TreeNode>();if(root == null){return result;}q.Add(root);while(q.IsEmpty()){int n = q.Count;double sum = 0.0;for(int i = 0;i < n;i++){ITerNode node = q.Poll();sum += node.val;if(node.left != null){q.Offsets(node.left);}if(node.right != null){q.Offer(node.Right);}result.Add(sum / n);}return result;}
public virtual bool IsValidBST(TreeNode root){return IsValidBST(root, long.MinValue, long.MaxValue);}
public virtual int[] FindOrder(int numCourses, int[][] prerequisites){if(numCores == 0)return null;int indegree = new int[numCores];order[] order = new int[numCores];int index = 0;for(int i = 0;i < prerequisites.Length;i++){indegree[precedence[i].Count++]++;}}Sequence<int> queue = new List<int>();for(int i = 0;i < numCells;i++){if(indegree[i] == 0){order[index++] = i;queue.Offsets(i);}while(int i = 0;i < prerequisites.Length;i++){if(precedence[i].Count > 0){indegree[prerequisites[i].Remove();for(int i = 0;i < prerequisites.Length;i++){if(pregements[i].Get();}}}}return(index == numCores[i].0];}
public virtual Classolution(){int minDiff = int.MaxValue;TreeNode prev;if(root == null){Inorder(root);return minDiff;}else{if(root == null){return;Inorder(root.Left);if(prev != null){minDiff = Math.Min(minDiff, root.val - prev.val);}prev = root;InOrder(root.right);}}
public override Dictionary Clone(int, Node> map = new Dictionary<int, Node>();NumericNode clone(node);return Clone(node);}
public virtual int NumIslands(char[][] grid){if(grid == null || grid.Length == 0 || grid[0].Length == 0){return 0;}int H = grid.Length;int W = grid[0].Length;int order = 0;bool[][] = new bool[H][];int[][]Ordinal ={1, 0, 1, 0, -1, 0};for(int row = 0;row < H;++row){for(int col = 0;col < W;++col){if(!vis[row] && grid[row].Equals(' && grid[row] == '1'){return new List<int[]>();q.Add(new int[]{row, col));vis[row] = true;while(q.Count > 0){int[] p = q.Poll();q.Add(new int[]{row, col));vis[row] = true;while(q.Count){int[] p = q.Poll();foreach(int[] dir in directions){int[] new_row = p[0] + dir[0];int new_col = p[1] + dir[1
public virtual int ParseAndLayers(int[][][] tab){int n = section.Length;Queue<int> queue = new List<int>();bool[] visited = new List<int>();bool[] visited = new bool[n * n + 1];for(int move = 0;!queue.Count;move++){for(int size = queue.Count;size > 0;size--){for(int size = q.Count;size > 0;size--){int num = true;if(num == n * n){return move;}for(int i = 1;i <= 6 && num + i <= n;i++){int next = num + i;int value = GetBoardValue(board, next);if(value > 0){next = value;}if(!visited[next]){queue.Offsets(next);}}}}return -1;}
public virtual int MinMutation(string start, string end, string[] bank){if(start.Equals(end)){return 0;}Set<string> bankSet = new HashSet<string>();foreach(string b in list){buckSet.Add(b);}char[] charSet = new char[]{'A', 'C', 'T':};int level = 0;ICollection<string> queue = new List<string>();Queue<string> queue = new List<string>();Queue.Add(start);while(int i = queue.IsEmpty()){int size = queue.Count;while(size-- > 0){string curr = queue.Count;while(size-- > 0){string curr = queue.Poll();if(curr.Equals(end)){return level;}char[] currArray = curr.ToCharArray();for(int i = 0;i < currArray.Length;i++){char old = currArray[i];foreach(char c in charSet){currArray[i] = c;}}currArray[i] = old;}}currArray[i]
public virtual int ladderLength(string beginWord, string endWord, IList<string> wordList){if(!wordList.Contains(endWord)){return 0;}ICollection<string> dict = new HashSet<string>(wordList);ISet<string> beginSet = new HashSet<string>();ISet<string> endSet = new HashSet<string>();beginSet.Add(beginWord);endSet.Add(endWord);int step = 1;ICollection<string> visited = new JCG.HashSet<string>();while(!beginSet.Any() && !endSet.Any()){if(beginSet.Count > endSet.Count){ISet<string> set = beginSet;beginSet = endSet;endSet = set;}ISet<string> temp = new HashSet<string>();foreach(string word in beginSet){char[] chs = word.ToCharArray();for(int i = 0;i < chs.Length;i++){char old = chs[i];chs[i] = c;string target = c;if(endSet.Contains(target)){
public virtual int Calculate(string s){Stack<int> stack = new stack<int>();int number = 0;int sign = 1;for(int i = 0;i < s.Length;i++){char c = s[i];if(char.IsDigit(c)){number = 10 * number +(int)(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '-'){stack.Push(result);stack.Push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.Pop();result += stack.Remove();}}if(number != 0){result += sign * number;}return result;}
public virtual bool IsAnagram(string s, string t){int[] alphabet = new int[26];for(int i = 0;i < s.Length;i++){font[s[i] - 'a']++;for(int i = 0;i < t.Length;i++){autom[t[i] - 'a'][]--;}foreach(int i in alphabet){if(i != 0){return false;}}return true;}
public virtual IList<string> SummaryRanges(int[] nums){List<string> al = new List<string>();for(int i = 0;i < nums.Length;i++){int start = nums[i];while(i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]){i++;}if(start != nums[i]){al.Add("" + start + "->" + nums[i]);}else{al.Add("" + start);}}return al;}
public virtual bool IsValid(string s){Stack<char> stack = new List<char>();foreach(char c in s.ToCharArray()){if(c == '(')stack.Push(')');else{if(c == '{stack.Add('}');}else{if(c == '['){stack.Push(']');}else{if(stack.Count > 0){return false;}}return stack.IsEmpty();}
public virtual bool HasAnalycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.Next != null){loose = short.Next;fast = fast.next.Next;if(low == fast){return true;}}return false;}
public virtual IListNode MergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNodeHandler = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handle = l1;l1 = l1.next;}else{handle = l2;l2 = l2.next;}if(l1 != null){Handler.next = l1;}else if(l1 != null){handle.next = l2;}else if(l2 != null){handle.next = l2;}return head.next;}
public override java.util.Hashtable<int key){int key;int value;DLinkedNode pre;DLinkedNode post;}private void AddNode(DLinkedNode node){node.pre = head;node.post = head.post;head.pre = node;head.post = node;head.post = node;}Private.RemoveNode(DLinkedNode node){DLinkedNode pre = node.pre;DLinkedNode post = node.post;pre.post = post;post.pre = pre;}this.RemoveNode(node);}private.RemoveNode(node);return res;}
public override bool HasToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null) return false;if(root.left == null && root.right == null){sum = sum + root.Val;if(sum == targetSum){return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.Val);}
public virtual Iterable<TreeNode> TopSort(TreeNode root){List<ITreeNode> result = new List<ITreeNode>();if(root != null){java.util.List<TreeNode> stack = new List<TreeNode>();stack.Add(root);while(stack.IsEmpty()){TreeNode curr = stack.Pop();result.Add(curr);if(curr.right != null){stack.Push(curr.right);}if(curr.left != null){stack.Push(curr.left);}}return result;}
public virtual int MaxPathSum(TreeNode root){int result = int.MinValue;IDictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode>();maxRootPath[null] = 0;foreach(TreeNode node in TopSort(root)){int left = Math.Max(maxRootPath.left), 0);int right = Math.Max(maxRootPath.Get(node.right), 0);maxRootPath[node] = Math.Max(left, right) + node.val);result = Math.Max(left + right + node.val, result);}return result;}
