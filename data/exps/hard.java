public int maxProfit(int k, int[] prices){int n = prices.length;if(n <= 1) return 0;if(k >= n/2){int maxPro = 0;for(int i = 1;i < n;i++){if(prices[i] > prices[i-1]) maxPro += prices[i] - prices[i-1];}return maxPro;}int[][] dp = new int[k+1][n];for(int i = 1;i <= k;i++){int localMax = dp[i-1][0] - prices[0];for(int j = 1;j < n;j++){dp[i][j] = Math.max(dp[i][j-1], prices[j] + localMax);localMax = Math.max(localMax, dp[i-1][j] - prices[j]);}}return dp[k][n-1];}
public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) ->(a[0] - b[0]));PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) ->(b[1] - a[1]));for(int i = 0;i < Profits.length;i++){pqCap.add(new int[]{Capital[i], Profits[i]});}for(int i = 0;i < k;i++){while(!pqCap.isEmpty() && pqCap.peek()[0] <= W){pqPro.add(pqCap.poll());}if(pqPro.isEmpty()) break;W += pqPro.poll()[1];}return W;}
public List<String> findWords(char[][] board, String[] words){List<String> res = new ArrayList<>();TrieNode root = buildTrie(words);for(int i = 0;i < board.length;i++){for(int j = 0;j < board[0].length;j++){dfs(board, i, j, root, res);}}return res;}public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res){char c = board[i][j];if(c == '#' || p.next[c - 'a'] == null) return;p = p.next[c - 'a'];if(p.word != null){res.add(p.word);p.word = null;}board[i][j] = '#';if(i > 0) dfs(board, i - 1, j ,p, res);if(j > 0) dfs(board, i, j - 1, p, res);if(i < board.length - 1) dfs(board, i + 1, j, p, res);if(j < board[0].length - 1) dfs(board, i, j + 1, p, res);board[i][j] = c;}public TrieNode buildTrie(String[] words){TrieNode root = new TrieNode();for(String w : words){TrieNode p = root;for(char c : w.toCharArray()){int i = c - 'a';if(p.next[i] == null) p.next[i] = new TrieNode();p = p.next[i];}p.word = w;}return root;}class TrieNode{TrieNode[] next = new TrieNode[26];String word;}
public int calculate(String s){Stack<Integer> stack = new Stack<Integer>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.length();i++){char c = s.charAt(i);if(Character.isDigit(c)){number = 10 * number +(int)(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '('){stack.push(result);stack.push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.pop();result += stack.pop();}}if(number != 0) result += sign * number;return result;}
public Iterable<TreeNode> topSort(TreeNode root){Deque<TreeNode> result = new LinkedList<>();if(root != null){Deque<TreeNode> stack = new LinkedList<>();stack.push(root);while(!stack.isEmpty()){TreeNode curr = stack.pop();result.push(curr);if(curr.right != null) stack.push(curr.right);if(curr.left != null) stack.push(curr.left);}}return result;}
public int maxPathSum(TreeNode root){int result = Integer.MIN_VALUE;Map<TreeNode, Integer> maxRootPath = new HashMap<>();maxRootPath.put(null, 0);for(TreeNode node : topSort(root)){int left = Math.max(maxRootPath.get(node.left), 0);int right = Math.max(maxRootPath.get(node.right), 0);maxRootPath.put(node, Math.max(left, right) + node.val);result = Math.max(left + right + node.val, result);}return result;}
