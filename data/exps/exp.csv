Name,Difficulty,Java,C#,Class_Or_Function
88. Merge Sorted Array,Easy,"public void merge(int[] nums1, int m, int[] nums2, int n) {
                for (int j = 0, i = m; j < n; j++) {
                                nums1[i] = nums2[j];
                                i++;
                }
                Arrays.sort(nums1);
}","public void Merge(int[] nums1, int m, int[] nums2, int n) {
        for (int j = 0, i = m; j < n; j++) {
            nums1[i] = nums2[j];
            i++;
        }
        Array.Sort(nums1);
    }",
120. Triangle,Medium,"public int minimumTotal(List<List<Integer>> triangle) {
        int n = triangle.size();
        int[][] dp = new int[n+1][n+1];

        for (int level=n-1; level>=0; level--)
                for (int i=0; i<=level; i++)
                        dp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);

        return dp[0][0];
}","public int MinimumTotal(IList<IList<int>> triangle) {
    int n = triangle.Count;
    int[][] dp = new int[n + 1][];
    for (int i = 0; i <= n; i++) {
        dp[i] = new int[n + 1];
    }

    for (int level = n - 1; level >= 0; level--) {
        for (int i = 0; i <= level; i++) {
            dp[level][i] = triangle[level][i] + Math.Min(dp[level + 1][i], dp[level + 1][i + 1]);
        }
    }

    return dp[0][0];
}",
188. Best Time to Buy and Sell Stock IV,Hard,"public int maxProfit(int k, int[] prices) {
        int n = prices.length;
        if (n <= 1)
                return 0;
        
        //if k >= n/2, then you can make maximum number of transactions.
        if (k >=  n/2) {
                int maxPro = 0;
                for (int i = 1; i < n; i++) {
                        if (prices[i] > prices[i-1])
                                maxPro += prices[i] - prices[i-1];
                }
                return maxPro;
        }
        
    int[][] dp = new int[k+1][n];
    for (int i = 1; i <= k; i++) {
            int localMax = dp[i-1][0] - prices[0];
            for (int j = 1; j < n; j++) {
                    dp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);
                    localMax = Math.max(localMax, dp[i-1][j] - prices[j]);
            }
    }
    return dp[k][n-1];
}","public int MaxProfit(int k, int[] prices) {
        int n = prices.Length;
        if (n <= 1)
            return 0;
        
        // If k is greater than or equal to n/2, you can make the maximum number of transactions.
        if (k >= n / 2) {
            int maxPro = 0;
            for (int i = 1; i < n; i++) {
                if (prices[i] > prices[i - 1])
                    maxPro += prices[i] - prices[i - 1];
            }
            return maxPro;
        }
        
        int[,] dp = new int[k + 1, n];
        for (int i = 1; i <= k; i++) {
            int localMax = dp[i - 1, 0] - prices[0];
            for (int j = 1; j < n; j++) {
                dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax);
                localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]);
            }
        }
        return dp[k, n - 1];
    }",
166. Fraction to Recurring Decimal,Medium,"public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) {
            return ""0"";
        }
        StringBuilder res = new StringBuilder();
        // ""+"" or ""-""
        res.append(((numerator > 0) ^ (denominator > 0)) ? ""-"" : """");
        long num = Math.abs((long)numerator);
        long den = Math.abs((long)denominator);
        
        // integral part
        res.append(num / den);
        num %= den;
        if (num == 0) {
            return res.toString();
        }
        
        // fractional part
        res.append(""."");
        HashMap<Long, Integer> map = new HashMap<Long, Integer>();
        map.put(num, res.length());
        while (num != 0) {
            num *= 10;
            res.append(num / den);
            num %= den;
            if (map.containsKey(num)) {
                int index = map.get(num);
                res.insert(index, ""("");
                res.append("")"");
                break;
            }
            else {
                map.put(num, res.length());
            }
        }
        return res.toString();
    }","public string FractionToDecimal(int numerator, int denominator) {
    if (numerator == 0) {
        return ""0"";
    }
    StringBuilder res = new StringBuilder();
    // ""+"" or ""-""
    res.Append((numerator > 0) ^ (denominator > 0) ? ""-"" : """");
    long num = System.Math.Abs((long)numerator);
    long den = System.Math.Abs((long)denominator);
    
    // integral part
    res.Append(num / den);
    num %= den;
    if (num == 0) {
        return res.ToString();
    }
    
    // fractional part
    res.Append(""."");
    Dictionary<long, int> map = new Dictionary<long, int>();
    map.Add(num, res.Length);
    while (num != 0) {
        num *= 10;
        res.Append(num / den);
        num %= den;
        if (map.ContainsKey(num)) {
            int index = map[num];
            res.Insert(index, ""("");
            res.Append("")"");
            break;
        }
        else {
            map.Add(num, res.Length);
        }
    }
    return res.ToString();
}",
128. Longest Consecutive Sequence,Medium,"public int longestConsecutive(int[] num) {
    int res = 0;
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int n : num) {
        if (!map.containsKey(n)) {
            int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0;
            int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0;
            // sum: length of the sequence n is in
            int sum = left + right + 1;
            map.put(n, sum);
            
            // keep track of the max length 
            res = Math.max(res, sum);
            
            // extend the length to the boundary(s)
            // of the sequence
            // will do nothing if n has no neighbors
            map.put(n - left, sum);
            map.put(n + right, sum);
        }
        else {
            // duplicates
            continue;
        }
    }
    return res;
}","public int LongestConsecutive(int[] num) {
        int res = 0;
        Dictionary<int, int> map = new Dictionary<int, int>();
        foreach (int n in num) {
            if (!map.ContainsKey(n)) {
                int left = map.ContainsKey(n - 1) ? map[n - 1] : 0;
                int right = map.ContainsKey(n + 1) ? map[n + 1] : 0;
                // sum: length of the sequence n is in
                int sum = left + right + 1;
                map[n] = sum;
                
                // keep track of the max length 
                res = System.Math.Max(res, sum);
                
                // extend the length to the boundary(s)
                // of the sequence
                // will do nothing if n has no neighbors
                map[n - left] = sum;
                map[n + right] = sum;
            }
            // else part is for duplicates, which is skipped in C# as in Java
        }
        return res;
    }",
502. IPO,Hard,"public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) -> (a[0] - b[0]));
        PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) -> (b[1] - a[1]));
        
        for (int i = 0; i < Profits.length; i++) {
            pqCap.add(new int[] {Capital[i], Profits[i]});
        }
        
        for (int i = 0; i < k; i++) {
            while (!pqCap.isEmpty() && pqCap.peek()[0] <= W) {
                pqPro.add(pqCap.poll());
            }
            
            if (pqPro.isEmpty()) break;
            
            W += pqPro.poll()[1];
        }
        
        return W;
    }","public int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        List<(int Capital, int Profit)> projects = new List<(int Capital, int Profit)>();
        for (int i = 0; i < Profits.Length; i++) {
            projects.Add((Capital[i], Profits[i]));
        }

        // Sort by capital in ascending order
        projects = projects.OrderBy(p => p.Capital).ToList();

        List<(int Capital, int Profit)> availableProjects = new List<(int Capital, int Profit)>();
        int index = 0;

        for (int i = 0; i < k; i++) {
            // Move projects that can be afforded to the available projects list
            while (index < projects.Count && projects[index].Capital <= W) {
                availableProjects.Add(projects[index]);
                index++;
            }

            // If there are no available projects, break
            if (!availableProjects.Any()) break;

            // Find the project with the maximum profit
            var maxProfitProject = availableProjects.OrderByDescending(p => p.Profit).First();
            W += maxProfitProject.Profit;

            // Remove the selected project from available projects
            availableProjects.Remove(maxProfitProject);
        }

        return W;
    }",
22. Generate Parentheses,Medium,"public List<String> generateParenthesis(int n) {
    
        
        HashSet<String> allCombos = new HashSet<>();
        
        for(int i=0;i<n;i++){
            
            if(allCombos.size()==0){                        //Initial situation
                allCombos.add(""()"");
            }
            else{
                HashSet<String> combos = new HashSet<>();
                for(String combo : allCombos){

                    //Add paranthesis to both sides
                    combos.add(combo+""()"");
                    combos.add(""()""+combo);

                    //Add paranthesis inside openings
                    for(int j=0;j<combo.length()-1;j++){
                        if(combo.charAt(j)=='(' && combo.charAt(j+1)==')'){             //Opening detected
                            combos.add(combo.substring(0,j+1)+""()""+combo.substring(j+1));
                            combos.add(combo.substring(0,j+1)+"")(""+combo.substring(j+1));
                        }
                    }
                }

                allCombos = combos;            
            }

        }
        
        return new ArrayList<String>(allCombos);
    }","public IList<string> GenerateParenthesis(int n) {
        HashSet<string> allCombos = new HashSet<string>();
        
        for (int i = 0; i < n; i++) {
            if (allCombos.Count == 0) { // Initial situation
                allCombos.Add(""()"");
            } else {
                HashSet<string> combos = new HashSet<string>();
                foreach (string combo in allCombos) {
                    // Add parenthesis to both sides
                    combos.Add(combo + ""()"");
                    combos.Add(""()"" + combo);

                    // Add parenthesis inside openings
                    for (int j = 0; j < combo.Length - 1; j++) {
                        if (combo[j] == '(' && combo[j + 1] == ')') { // Opening detected
                            combos.Add(combo.Substring(0, j + 1) + ""()"" + combo.Substring(j + 1));
                            combos.Add(combo.Substring(0, j + 1) + "")("" + combo.Substring(j + 1));
                        }
                    }
                }

                allCombos = combos;
            }
        }

        return new List<string>(allCombos);
    }",
212. Word Search II,Hard,"public List<String> findWords(char[][] board, String[] words) {
    List<String> res = new ArrayList<>();
    TrieNode root = buildTrie(words);
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs (board, i, j, root, res);
        }
    }
    return res;
}

public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {
    char c = board[i][j];
    if (c == '#' || p.next[c - 'a'] == null) return;
    p = p.next[c - 'a'];
    if (p.word != null) {   // found one
        res.add(p.word);
        p.word = null;     // de-duplicate
    }

    board[i][j] = '#';
    if (i > 0) dfs(board, i - 1, j ,p, res); 
    if (j > 0) dfs(board, i, j - 1, p, res);
    if (i < board.length - 1) dfs(board, i + 1, j, p, res); 
    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); 
    board[i][j] = c;
}

public TrieNode buildTrie(String[] words) {
    TrieNode root = new TrieNode();
    for (String w : words) {
        TrieNode p = root;
        for (char c : w.toCharArray()) {
            int i = c - 'a';
            if (p.next[i] == null) p.next[i] = new TrieNode();
            p = p.next[i];
       }
       p.word = w;
    }
    return root;
}

class TrieNode {
    TrieNode[] next = new TrieNode[26];
    String word;
}","public class Solution {
    public IList<string> FindWords(char[][] board, string[] words) {
        List<string> res = new List<string>();
        TrieNode root = BuildTrie(words);
        for (int i = 0; i < board.Length; i++) {
            for (int j = 0; j < board[0].Length; j++) {
                Dfs(board, i, j, root, res);
            }
        }
        return res;
    }

    public void Dfs(char[][] board, int i, int j, TrieNode p, List<string> res) {
        char c = board[i][j];
        if (c == '#' || p.Next[c - 'a'] == null) return;
        p = p.Next[c - 'a'];
        if (p.Word != null) { // found one
            res.Add(p.Word);
            p.Word = null; // de-duplicate
        }

        board[i][j] = '#';
        if (i > 0) Dfs(board, i - 1, j, p, res);
        if (j > 0) Dfs(board, i, j - 1, p, res);
        if (i < board.Length - 1) Dfs(board, i + 1, j, p, res);
        if (j < board[0].Length - 1) Dfs(board, i, j + 1, p, res);
        board[i][j] = c;
    }

    public TrieNode BuildTrie(string[] words) {
        TrieNode root = new TrieNode();
        foreach (string w in words) {
            TrieNode p = root;
            foreach (char c in w) {
                int i = c - 'a';
                if (p.Next[i] == null) p.Next[i] = new TrieNode();
                p = p.Next[i];
            }
            p.Word = w;
        }
        return root;
    }
}

public class TrieNode {
    public TrieNode[] Next = new TrieNode[26];
    public string Word;
}",Y
72. Edit Distance,Medium,"public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        int[][] cost = new int[m + 1][n + 1];
        for(int i = 0; i <= m; i++)
            cost[i][0] = i;
        for(int i = 1; i <= n; i++)
            cost[0][i] = i;
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(word1.charAt(i) == word2.charAt(j))
                    cost[i + 1][j + 1] = cost[i][j];
                else {
                    int a = cost[i][j];
                    int b = cost[i][j + 1];
                    int c = cost[i + 1][j];
                    cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);
                    cost[i + 1][j + 1]++;
                }
            }
        }
        return cost[m][n];
    }","public int MinDistance(string word1, string word2) {
        int m = word1.Length;
        int n = word2.Length;

        int[,] cost = new int[m + 1, n + 1];
        for (int i = 0; i <= m; i++)
            cost[i, 0] = i;
        for (int i = 1; i <= n; i++)
            cost[0, i] = i;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (word1[i] == word2[j])
                    cost[i + 1, j + 1] = cost[i, j];
                else {
                    int a = cost[i, j];
                    int b = cost[i, j + 1];
                    int c = cost[i + 1, j];
                    cost[i + 1, j + 1] = Math.Min(a, Math.Min(b, c)) + 1;
                }
            }
        }
        return cost[m, n];
    }",
211. Design Add and Search Words Data Structure,Medium,"class WordDictionary {
    private WordDictionary[] children;
    boolean isEndOfWord;
    // Initialize your data structure here. 
    public WordDictionary() {
        children = new WordDictionary[26];
        isEndOfWord = false;
    }
    
    // Adds a word into the data structure. 
    public void addWord(String word) {
        WordDictionary curr = this;
        for(char c: word.toCharArray()){
            if(curr.children[c - 'a'] == null)
                curr.children[c - 'a'] = new WordDictionary();
            curr = curr.children[c - 'a'];
        }
        curr.isEndOfWord = true;
    }
    
    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
    public boolean search(String word) {
        WordDictionary curr = this;
        for(int i = 0; i < word.length(); ++i){
            char c = word.charAt(i);
            if(c == '.'){
                for(WordDictionary ch: curr.children)
                    if(ch != null && ch.search(word.substring(i+1))) return true;
                return false;
            }
            if(curr.children[c - 'a'] == null) return false;
            curr = curr.children[c - 'a'];
        }
        return curr != null && curr.isEndOfWord;
    }
}","public class WordDictionary {
    private WordDictionary[] children;
    private bool isEndOfWord;

    // Initialize your data structure here. 
    public WordDictionary() {
        children = new WordDictionary[26];
        isEndOfWord = false;
    }
    
    // Adds a word into the data structure. 
    public void AddWord(string word) {
        WordDictionary curr = this;
        foreach (char c in word) {
            if (curr.children[c - 'a'] == null)
                curr.children[c - 'a'] = new WordDictionary();
            curr = curr.children[c - 'a'];
        }
        curr.isEndOfWord = true;
    }
    
    // Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. 
    public bool Search(string word) {
        return Search(word, 0, this);
    }

    private bool Search(string word, int index, WordDictionary node) {
        if (node == null) return false;
        if (index == word.Length) return node.isEndOfWord;

        char c = word[index];
        if (c == '.') {
            foreach (WordDictionary child in node.children) {
                if (child != null && Search(word, index + 1, child)) return true;
            }
            return false;
        } else {
            return Search(word, index + 1, node.children[c - 'a']);
        }
    }
}",Y
221. Maximal Square,Medium,"public int maximalSquare(char[][] a) {
    if(a.length == 0) return 0;
    int m = a.length, n = a[0].length, result = 0;
    int[][] b = new int[m+1][n+1];
    for (int i = 1 ; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if(a[i-1][j-1] == '1') {
                b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;
                result = Math.max(b[i][j], result); // update result
            }
        }
    }
    return result*result;
}","public int MaximalSquare(char[][] a) {
    if (a.Length == 0) return 0;
    int m = a.Length, n = a[0].Length, result = 0;
    int[,] b = new int[m + 1, n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (a[i - 1][j - 1] == '1') {
                b[i, j] = Math.Min(Math.Min(b[i, j - 1], b[i - 1, j - 1]), b[i - 1, j]) + 1;
                result = Math.Max(b[i, j], result); // update result
            }
        }
    }
    return result * result;
}",
103. Binary Tree Zigzag Level Order Traversal,Medium,"public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) 
    {
        List<List<Integer>> sol = new ArrayList<>();
        travel(root, sol, 0);
        return sol;
    }
    
    private void travel(TreeNode curr, List<List<Integer>> sol, int level)
    {
        if(curr == null) return;
        
        if(sol.size() <= level)
        {
            List<Integer> newLevel = new LinkedList<>();
            sol.add(newLevel);
        }
        
        List<Integer> collection  = sol.get(level);
        if(level % 2 == 0) collection.add(curr.val);
        else collection.add(0, curr.val);
        
        travel(curr.left, sol, level + 1);
        travel(curr.right, sol, level + 1);
    }
}","public class Solution {
    public IList<IList<int>> ZigzagLevelOrder(TreeNode root) {
        IList<IList<int>> sol = new List<IList<int>>();
        Travel(root, sol, 0);
        return sol;
    }

    private void Travel(TreeNode curr, IList<IList<int>> sol, int level) {
        if (curr == null) return;

        if (sol.Count <= level) {
            IList<int> newLevel = new List<int>();
            sol.Add(newLevel);
        }

        IList<int> collection = sol[level];
        if (level % 2 == 0) collection.Add(curr.val);
        else collection.Insert(0, curr.val);

        Travel(curr.left, sol, level + 1);
        Travel(curr.right, sol, level + 1);
    }
}",Y
637. Average of Levels in Binary Tree,Easy,"public List<Double> averageOfLevels(TreeNode root) {
    List<Double> result = new ArrayList<>();
    Queue<TreeNode> q = new LinkedList<>();
    
    if(root == null) return result;
    q.add(root);
    while(!q.isEmpty()) {
        int n = q.size();
        double sum = 0.0;
        for(int i = 0; i < n; i++) {
            TreeNode node = q.poll();
            sum += node.val;
            if(node.left != null) q.offer(node.left);
            if(node.right != null) q.offer(node.right);
        }
        result.add(sum / n);
    }
    return result;
}","public IList<double> AverageOfLevels(TreeNode root) {
        List<double> result = new List<double>();
        Queue<TreeNode> q = new Queue<TreeNode>();
    
        if (root == null) return result;
        q.Enqueue(root);
        while (q.Count > 0) {
            int n = q.Count;
            double sum = 0.0;
            for (int i = 0; i < n; i++) {
                TreeNode node = q.Dequeue();
                sum += node.val;
                if (node.left != null) q.Enqueue(node.left);
                if (node.right != null) q.Enqueue(node.right);
            }
            result.Add(sum / n);
        }
        return result;
    }",
98. Validate Binary Search Tree,Medium,"public class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    
    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {
        if (root == null) return true;
        if (root.val >= maxVal || root.val <= minVal) return false;
        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);
    }
}","public class Solution {
    public bool IsValidBST(TreeNode root) {
        return IsValidBST(root, long.MinValue, long.MaxValue);
    }
    
    public bool IsValidBST(TreeNode root, long minVal, long maxVal) {
        if (root == null) return true;
        if (root.val >= maxVal || root.val <= minVal) return false;
        return IsValidBST(root.left, minVal, root.val) && IsValidBST(root.right, root.val, maxVal);
    }
}",Y
210. Course Schedule II,Medium,"public int[] findOrder(int numCourses, int[][] prerequisites) { 
    if (numCourses == 0) return null;
    // Convert graph presentation from edges to indegree of adjacent list.
    int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;
    for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.
        indegree[prerequisites[i][0]]++;    

    Queue<Integer> queue = new LinkedList<Integer>();
    for (int i = 0; i < numCourses; i++) 
        if (indegree[i] == 0) {
            // Add the course to the order because it has no prerequisites.
            order[index++] = i;
            queue.offer(i);
        }

    // How many courses don't need prerequisites. 
    while (!queue.isEmpty()) {
        int prerequisite = queue.poll(); // Already finished this prerequisite course.
        for (int i = 0; i < prerequisites.length; i++)  {
            if (prerequisites[i][1] == prerequisite) {
                indegree[prerequisites[i][0]]--; 
                if (indegree[prerequisites[i][0]] == 0) {
                    // If indegree is zero, then add the course to the order.
                    order[index++] = prerequisites[i][0];
                    queue.offer(prerequisites[i][0]);
                }
            } 
        }
    }

    return (index == numCourses) ? order : new int[0];
}","public int[] FindOrder(int numCourses, int[][] prerequisites) {
    if (numCourses == 0) return null;
    // Convert graph presentation from edges to indegree of adjacent list.
    int[] indegree = new int[numCourses], order = new int[numCourses];
    int index = 0;
    for (int i = 0; i < prerequisites.Length; i++) // Indegree - how many prerequisites are needed.
        indegree[prerequisites[i][0]]++;

    Queue<int> queue = new Queue<int>();
    for (int i = 0; i < numCourses; i++)
        if (indegree[i] == 0) {
            // Add the course to the order because it has no prerequisites.
            order[index++] = i;
            queue.Enqueue(i);
        }

    // How many courses don't need prerequisites.
    while (queue.Count > 0) {
        int prerequisite = queue.Dequeue(); // Already finished this prerequisite course.
        for (int i = 0; i < prerequisites.Length; i++) {
            if (prerequisites[i][1] == prerequisite) {
                indegree[prerequisites[i][0]]--;
                if (indegree[prerequisites[i][0]] == 0) {
                    // If indegree is zero, then add the course to the order.
                    order[index++] = prerequisites[i][0];
                    queue.Enqueue(prerequisites[i][0]);
                }
            }
        }
    }

    return (index == numCourses) ? order : new int[0];
}",
530. Minimum Absolute Difference in BST,Easy,"public class Solution {
    
    int minDiff = Integer.MAX_VALUE;
    TreeNode prev;
    
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return minDiff;
    }
    
    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        if (prev != null) minDiff = Math.min(minDiff, root.val - prev.val);
        prev = root;
        inorder(root.right);
    }

}","public class Solution {
    int minDiff = int.MaxValue;
    TreeNode prev;

    public int GetMinimumDifference(TreeNode root) {
        Inorder(root);
        return minDiff;
    }

    public void Inorder(TreeNode root) {
        if (root == null) return;
        Inorder(root.left);
        if (prev != null) minDiff = Math.Min(minDiff, root.val - prev.val);
        prev = root;
        Inorder(root.right);
    }
}",Y
133. Clone Graph,Medium,"class Solution {
    public HashMap<Integer, Node> map = new HashMap<>();
    
    public Node cloneGraph(Node node) {
        return clone(node);
    }
    
    public Node clone(Node node) {
        if (node == null) return null;
        
        if (map.containsKey(node.val)) 
            return map.get(node.val);
        
        Node newNode = new Node(node.val, new ArrayList<Node>());
        map.put(newNode.val, newNode);
        for (Node neighbor : node.neighbors) 
            newNode.neighbors.add(clone(neighbor));
        return newNode;
    }
}","public class Solution {
    private Dictionary<int, Node> map = new Dictionary<int, Node>();

    public Node CloneGraph(Node node) {
        return Clone(node);
    }

    private Node Clone(Node node) {
        if (node == null) return null;

        if (map.ContainsKey(node.val))
            return map[node.val];

        Node newNode = new Node(node.val, new List<Node>());
        map.Add(newNode.val, newNode);
        foreach (Node neighbor in node.neighbors)
            newNode.neighbors.Add(Clone(neighbor));
        return newNode;
    }
}",Y
200. Number of Islands,Medium,"public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int H = grid.length;
        int W = grid[0].length;
        int answer = 0;
        boolean[][] vis = new boolean[H][W];
        int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

        for (int row = 0; row < H; ++row) {
            for (int col = 0; col < W; ++col) {
                if (!vis[row][col] && grid[row][col] == '1') {
                    answer++;
                    Queue<int[]> q = new LinkedList<>();
                    q.add(new int[]{row, col});
                    vis[row][col] = true;

                    while (!q.isEmpty()) {
                        int[] p = q.poll();
                        for (int[] dir : directions) {
                            int new_row = p[0] + dir[0];
                            int new_col = p[1] + dir[1];

                            if (new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !vis[new_row][new_col] && grid[new_row][new_col] == '1') {
                                q.add(new int[]{new_row, new_col});
                                vis[new_row][new_col] = true;
                            }
                        }
                    }
                }
            }
        }
        return answer;
    }","public int NumIslands(char[][] grid) {
    if (grid == null || grid.Length == 0 || grid[0].Length == 0) {
        return 0;
    }
    int H = grid.Length;
    int W = grid[0].Length;
    int answer = 0;
    bool[,] vis = new bool[H, W];
    int[][] directions = new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 }, new int[] { -1, 0 }, new int[] { 0, -1 } };

    for (int row = 0; row < H; ++row) {
        for (int col = 0; col < W; ++col) {
            if (!vis[row, col] && grid[row][col] == '1') {
                answer++;
                Queue<int[]> q = new Queue<int[]>();
                q.Enqueue(new int[] { row, col });
                vis[row, col] = true;

                while (q.Count > 0) {
                    int[] p = q.Dequeue();
                    foreach (int[] dir in directions) {
                        int newRow = p[0] + dir[0];
                        int newCol = p[1] + dir[1];

                        if (newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !vis[newRow, newCol] && grid[newRow][newCol] == '1') {
                            q.Enqueue(new int[] { newRow, newCol });
                            vis[newRow, newCol] = true;
                        }
                    }
                }
            }
        }
    }
    return answer;
}",
909. Snakes and Ladders,Medium,"public int snakesAndLadders(int[][] board) {
        int n = board.length;
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        boolean[] visited = new boolean[n * n + 1];
        for (int move = 0; !queue.isEmpty(); move++) {
            for (int size = queue.size(); size > 0; size--) {
                int num = queue.poll();
                if (visited[num]) continue;
                visited[num] = true;
                if (num == n * n) return move;
                for (int i = 1; i <= 6 && num + i <= n * n; i++) {
                    int next = num + i;
                    int value = getBoardValue(board, next);
                    if (value > 0) next = value;
                    if (!visited[next]) queue.offer(next);
                }
            }
        }
        return -1;
    }

    private int getBoardValue(int[][] board, int num) {
        int n = board.length;
        int r = (num - 1) / n;
        int x = n - 1 - r;
        int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;
        return board[x][y];
    }","public int SnakesAndLadders(int[][] board) {
    int n = board.Length;
    Queue<int> queue = new Queue<int>();
    queue.Enqueue(1);
    bool[] visited = new bool[n * n + 1];
    for (int move = 0; !queue.Count.Equals(0); move++) {
        for (int size = queue.Count; size > 0; size--) {
            int num = queue.Dequeue();
            if (visited[num]) continue;
            visited[num] = true;
            if (num == n * n) return move;
            for (int i = 1; i <= 6 && num + i <= n * n; i++) {
                int next = num + i;
                int value = GetBoardValue(board, next);
                if (value > 0) next = value;
                if (!visited[next]) queue.Enqueue(next);
            }
        }
    }
    return -1;
}

private int GetBoardValue(int[][] board, int num) {
    int n = board.Length;
    int r = (num - 1) / n;
    int x = n - 1 - r;
    int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;
    return board[x][y];
}",Y
433. Minimum Genetic Mutation,Medium,"public int minMutation(String start, String end, String[] bank) {
        if(start.equals(end)) return 0;
        
        Set<String> bankSet = new HashSet<>();
        for(String b: bank) bankSet.add(b);
        
        char[] charSet = new char[]{'A', 'C', 'G', 'T'};
        
        int level = 0;
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        visited.add(start);
        
        while(!queue.isEmpty()) {
            int size = queue.size();
            while(size-- > 0) {
                String curr = queue.poll();
                if(curr.equals(end)) return level;
                
                char[] currArray = curr.toCharArray();
                for(int i = 0; i < currArray.length; i++) {
                    char old = currArray[i];
                    for(char c: charSet) {
                        currArray[i] = c;
                        String next = new String(currArray);
                        if(!visited.contains(next) && bankSet.contains(next)) {
                            visited.add(next);
                            queue.offer(next);
                        }
                    }
                    currArray[i] = old;
                }
            }
            level++;
        }
        return -1;
    }","public int MinMutation(string start, string end, string[] bank) {
    if (start.Equals(end)) return 0;

    HashSet<string> bankSet = new HashSet<string>(bank);

    char[] charSet = new char[] { 'A', 'C', 'G', 'T' };

    int level = 0;
    HashSet<string> visited = new HashSet<string>();
    Queue<string> queue = new Queue<string>();
    queue.Enqueue(start);
    visited.Add(start);

    while (queue.Count > 0) {
        int size = queue.Count;
        while (size-- > 0) {
            string curr = queue.Dequeue();
            if (curr.Equals(end)) return level;

            char[] currArray = curr.ToCharArray();
            for (int i = 0; i < currArray.Length; i++) {
                char old = currArray[i];
                foreach (char c in charSet) {
                    currArray[i] = c;
                    string next = new string(currArray);
                    if (!visited.Contains(next) && bankSet.Contains(next)) {
                        visited.Add(next);
                        queue.Enqueue(next);
                    }
                }
                currArray[i] = old;
            }
        }
        level++;
    }
    return -1;
}",
127. Word Ladder,Medium,"public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) {
            return 0;
        }
        Set<String> dict = new HashSet<>(wordList);
        Set<String> beginSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        beginSet.add(beginWord);
        endSet.add(endWord);

        int step = 1;
        Set<String> visited = new HashSet<>();
        while (!beginSet.isEmpty() && !endSet.isEmpty()) {
            if (beginSet.size() > endSet.size()) {
                Set<String> set = beginSet;
                beginSet = endSet;
                endSet = set;
            }
            Set<String> temp = new HashSet<>();
            for (String word : beginSet) {
                char[] chs = word.toCharArray();
                for (int i = 0; i < chs.length; i++) {
                    for (char c = 'a'; c <= 'z'; c++) {
                        char old = chs[i];
                        chs[i] = c;
                        String target = String.valueOf(chs);
                        if (endSet.contains(target)) {
                            return step + 1;
                        }
                        if (!visited.contains(target) && dict.contains(target)) {
                            temp.add(target);
                            visited.add(target);
                        }
                        chs[i] = old;
                    }
                }
            }
            beginSet = temp;
            step++;
        }
        return 0;
    }","public int LadderLength(string beginWord, string endWord, IList<string> wordList) {
    if (!wordList.Contains(endWord)) {
        return 0;
    }
    HashSet<string> dict = new HashSet<string>(wordList);
    HashSet<string> beginSet = new HashSet<string>(), endSet = new HashSet<string>();
    beginSet.Add(beginWord);
    endSet.Add(endWord);

    int step = 1;
    HashSet<string> visited = new HashSet<string>();
    while (beginSet.Count > 0 && endSet.Count > 0) {
        if (beginSet.Count > endSet.Count) {
            var set = beginSet;
            beginSet = endSet;
            endSet = set;
        }
        HashSet<string> temp = new HashSet<string>();
        foreach (string word in beginSet) {
            char[] chs = word.ToCharArray();
            for (int i = 0; i < chs.Length; i++) {
                for (char c = 'a'; c <= 'z'; c++) {
                    char old = chs[i];
                    chs[i] = c;
                    string target = new string(chs);
                    if (endSet.Contains(target)) {
                        return step + 1;
                    }
                    if (!visited.Contains(target) && dict.Contains(target)) {
                        temp.Add(target);
                        visited.Add(target);
                    }
                    chs[i] = old;
                }
            }
        }
        beginSet = temp;
        step++;
    }
    return 0;
}",
224. Basic Calculator,Hard,"public int calculate(String s) {
    Stack<Integer> stack = new Stack<Integer>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for(int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if(Character.isDigit(c)){
            number = 10 * number + (int)(c - '0');
        }else if(c == '+'){
            result += sign * number;
            number = 0;
            sign = 1;
        }else if(c == '-'){
            result += sign * number;
            number = 0;
            sign = -1;
        }else if(c == '('){
            //we push the result first, then sign;
            stack.push(result);
            stack.push(sign);
            //reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        }else if(c == ')'){
            result += sign * number;  
            number = 0;
            result *= stack.pop();    //stack.pop() is the sign before the parenthesis
            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis
            
        }
    }
    if(number != 0) result += sign * number;
    return result;
}","public int Calculate(string s) {
    Stack<int> stack = new Stack<int>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for (int i = 0; i < s.Length; i++) {
        char c = s[i];
        if (char.IsDigit(c)) {
            number = 10 * number + (c - '0');
        } else if (c == '+') {
            result += sign * number;
            number = 0;
            sign = 1;
        } else if (c == '-') {
            result += sign * number;
            number = 0;
            sign = -1;
        } else if (c == '(') {
            // we push the result first, then sign;
            stack.Push(result);
            stack.Push(sign);
            // reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        } else if (c == ')') {
            result += sign * number;  
            number = 0;
            result *= stack.Pop();    // stack.Pop() is the sign before the parenthesis
            result += stack.Pop();   // stack.Pop() now is the result calculated before the parenthesis
            
        }
    }
    if (number != 0) result += sign * number;
    return result;
}",
242. Valid Anagram,Easy,"public boolean isAnagram(String s, String t) {
        int[] alphabet = new int[26];
        for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++;
        for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--;
        for (int i : alphabet) if (i != 0) return false;
        return true;
    }","public bool IsAnagram(string s, string t) {
    int[] alphabet = new int[26];
    for (int i = 0; i < s.Length; i++) alphabet[s[i] - 'a']++;
    for (int i = 0; i < t.Length; i++) alphabet[t[i] - 'a']--;
    foreach (int i in alphabet) if (i != 0) return false;
    return true;
}",
228. Summary Ranges,Easy,"public List<String> summaryRanges(int[] nums) {
       ArrayList<String> al=new ArrayList<>();
        
        for(int i=0;i<nums.length;i++){
            int start=nums[i];
            while(i+1<nums.length && nums[i]+1==nums[i+1])
                i++;
            
            if(start!=nums[i]){
                al.add(""""+start+""->""+nums[i]);
            }
            else{
                al.add(""""+start);
            }
        }
        return al;
    }","public List<string> SummaryRanges(int[] nums) {
    List<string> ranges = new List<string>();
    
    for (int i = 0; i < nums.Length; i++) {
        int start = nums[i];
        while (i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]) {
            i++;
        }

        if (start != nums[i]) {
            ranges.Add(start + ""->"" + nums[i]);
        } else {
            ranges.Add(start.ToString());
        }
    }
    return ranges;
}",
20. Valid Parentheses,Easy,"public boolean isValid(String s) {
	Stack<Character> stack = new Stack<Character>();
	for (char c : s.toCharArray()) {
		if (c == '(')
			stack.push(')');
		else if (c == '{')
			stack.push('}');
		else if (c == '[')
			stack.push(']');
		else if (stack.isEmpty() || stack.pop() != c)
			return false;
	}
	return stack.isEmpty();
}","public bool IsValid(string s) {
    Stack<char> stack = new Stack<char>();
    foreach (char c in s) {
        if (c == '(')
            stack.Push(')');
        else if (c == '{')
            stack.Push('}');
        else if (c == '[')
            stack.Push(']');
        else if (stack.Count == 0 || stack.Pop() != c)
            return false;
    }
    return stack.Count == 0;
}",
141. Linked List Cycle,Easy,"public boolean hasCycle(ListNode head) {
  ListNode slow = head, fast = head;
  
  while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
    
    if (slow == fast) 
        return true;
  }
  
  return false;
}","public bool HasCycle(ListNode head) {
    ListNode slow = head, fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) 
            return true;
    }

    return false;
}",
21. Merge Two Sorted Lists,Easy,"public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode handler = head;
        while(l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                handler.next = l1;
                l1 = l1.next;
            } else {
                handler.next = l2;
                l2 = l2.next;
            }
            handler = handler.next;
        }
        
        if (l1 != null) {
            handler.next = l1;
        } else if (l2 != null) {
            handler.next = l2;
        }
        
        return head.next;
    }","public ListNode MergeTwoLists(ListNode l1, ListNode l2) {
    ListNode head = new ListNode(0);
    ListNode handler = head;
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            handler.next = l1;
            l1 = l1.next;
        } else {
            handler.next = l2;
            l2 = l2.next;
        }
        handler = handler.next;
    }

    if (l1 != null) {
        handler.next = l1;
    } else if (l2 != null) {
        handler.next = l2;
    }

    return head.next;
}",
146. LRU Cache,Medium,"import java.util.Hashtable;


public class LRUCache {

class DLinkedNode {
  int key;
  int value;
  DLinkedNode pre;
  DLinkedNode post;
}

/**
 * Always add the new node right after head;
 */
private void addNode(DLinkedNode node) {
    
  node.pre = head;
  node.post = head.post;

  head.post.pre = node;
  head.post = node;
}

/**
 * Remove an existing node from the linked list.
 */
private void removeNode(DLinkedNode node){
  DLinkedNode pre = node.pre;
  DLinkedNode post = node.post;

  pre.post = post;
  post.pre = pre;
}

/**
 * Move certain node in between to the head.
 */
private void moveToHead(DLinkedNode node){
  this.removeNode(node);
  this.addNode(node);
}

// pop the current tail. 
private DLinkedNode popTail(){
  DLinkedNode res = tail.pre;
  this.removeNode(res);
  return res;
}

private Hashtable<Integer, DLinkedNode> 
  cache = new Hashtable<Integer, DLinkedNode>();
private int count;
private int capacity;
private DLinkedNode head, tail;

public LRUCache(int capacity) {
  this.count = 0;
  this.capacity = capacity;

  head = new DLinkedNode();
  head.pre = null;

  tail = new DLinkedNode();
  tail.post = null;

  head.post = tail;
  tail.pre = head;
}

public int get(int key) {

  DLinkedNode node = cache.get(key);
  if(node == null){
    return -1; // should raise exception here.
  }

  // move the accessed node to the head;
  this.moveToHead(node);

  return node.value;
}


public void put(int key, int value) {
  DLinkedNode node = cache.get(key);

  if(node == null){

    DLinkedNode newNode = new DLinkedNode();
    newNode.key = key;
    newNode.value = value;

    this.cache.put(key, newNode);
    this.addNode(newNode);

    ++count;

    if(count > capacity){
      // pop the tail
      DLinkedNode tail = this.popTail();
      this.cache.remove(tail.key);
      --count;
    }
  }else{
    // update the value.
    node.value = value;
    this.moveToHead(node);
  }
}

}","public class LRUCache {

    class DLinkedNode {
        public int key;
        public int value;
        public DLinkedNode prev;
        public DLinkedNode next;
    }

    private void AddNode(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;

        head.next.prev = node;
        head.next = node;
    }

    private void RemoveNode(DLinkedNode node) {
        DLinkedNode prev = node.prev;
        DLinkedNode next = node.next;

        prev.next = next;
        next.prev = prev;
    }

    private void MoveToHead(DLinkedNode node) {
        RemoveNode(node);
        AddNode(node);
    }

    private DLinkedNode PopTail() {
        DLinkedNode res = tail.prev;
        RemoveNode(res);
        return res;
    }

    private Dictionary<int, DLinkedNode> cache = new Dictionary<int, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.count = 0;
        this.capacity = capacity;

        head = new DLinkedNode();
        head.prev = null;

        tail = new DLinkedNode();
        tail.next = null;

        head.next = tail;
        tail.prev = head;
    }

    public int Get(int key) {
        if (!cache.ContainsKey(key)) {
            return -1;
        }

        DLinkedNode node = cache[key];
        MoveToHead(node);

        return node.value;
    }

    public void Put(int key, int value) {
        if (!cache.ContainsKey(key)) {
            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.value = value;

            cache[key] = newNode;
            AddNode(newNode);

            ++count;

            if (count > capacity) {
                DLinkedNode tail = PopTail();
                cache.Remove(tail.key);
                --count;
            }
        } else {
            DLinkedNode node = cache[key];
            node.value = value;
            MoveToHead(node);
        }
    }
}",Y
112. Path Sum,Easy,"class Solution {
    public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){
        if(root == null)
            return false;
        if(root.left == null && root.right == null){
            sum = sum + root.val;
            if(sum == targetSum)
                return true;   
        }
        return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);
    }
    public boolean hasPathSum(TreeNode root, int targetSum) {
        int sum = 0;
        return rootToLeafPathSum(root, targetSum, sum);
    }
}","public class Solution {
    public bool RootToLeafPathSum(TreeNode root, int targetSum, int sum) {
        if (root == null)
            return false;
        if (root.left == null && root.right == null) {
            sum += root.val;
            if (sum == targetSum)
                return true;
        }
        return RootToLeafPathSum(root.left, targetSum, sum + root.val) || RootToLeafPathSum(root.right, targetSum, sum + root.val);
    }

    public bool HasPathSum(TreeNode root, int targetSum) {
        int sum = 0;
        return RootToLeafPathSum(root, targetSum, sum);
    }
}",Y
124. Binary Tree Maximum Path Sum (P1),Hard,"public Iterable<TreeNode> topSort(TreeNode root) {
    Deque<TreeNode> result = new LinkedList<>();
    if (root != null) {
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode curr = stack.pop();
            result.push(curr);
            if (curr.right != null) stack.push(curr.right);
            if (curr.left != null) stack.push(curr.left);
        }
    }
    return result;
}","public IEnumerable<TreeNode> TopSort(TreeNode root) {
    LinkedList<TreeNode> result = new LinkedList<TreeNode>();
    if (root != null) {
        LinkedList<TreeNode> stack = new LinkedList<TreeNode>();
        stack.AddFirst(root);
        while (stack.Count > 0) {
            TreeNode curr = stack.First.Value;
            stack.RemoveFirst();
            result.AddFirst(curr);
            if (curr.right != null) stack.AddFirst(curr.right);
            if (curr.left != null) stack.AddFirst(curr.left);
        }
    }
    return result;
}",
124. Binary Tree Maximum Path Sum (P2),Hard,"public int maxPathSum(TreeNode root) {
    int result = Integer.MIN_VALUE;
    Map<TreeNode, Integer> maxRootPath = new HashMap<>(); // cache
    maxRootPath.put(null, 0); // for simplicity we want to handle null nodes
    for (TreeNode node : topSort(root)) {
        // as we process nodes in post-order their children are already cached
        int left = Math.max(maxRootPath.get(node.left), 0);
        int right = Math.max(maxRootPath.get(node.right), 0); 
        maxRootPath.put(node, Math.max(left, right) + node.val);
        result = Math.max(left + right + node.val, result);
    }
    return result;
}","public int MaxPathSum(TreeNode root) {
    int result = int.MinValue;
    Dictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode, int>(); // cache
    maxRootPath[null] = 0; // for simplicity we want to handle null nodes
    foreach (TreeNode node in TopSort(root)) {
        // as we process nodes in post-order their children are already cached
        int left = Math.Max(maxRootPath.GetValueOrDefault(node.left, 0), 0);
        int right = Math.Max(maxRootPath.GetValueOrDefault(node.right, 0), 0); 
        maxRootPath[node] = Math.Max(left, right) + node.val;
        result = Math.Max(left + right + node.val, result);
    }
    return result;
}",