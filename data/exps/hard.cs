public int MaxProfit(int k, int[] prices){int n = prices.Length;if(n <= 1) return 0;if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(prices[i] > prices[i - 1]) maxPro += prices[i] - prices[i - 1];}return maxPro;}int[,] dp = new int[k + 1, n];for(int i = 1;i <= k;i++){int localMax = dp[i - 1, 0] - prices[0];for(int j = 1;j < n;j++){dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax);localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]);}}return dp[k, n - 1];}
public int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital){List<(int Capital, int Profit)> projects = new List<(int Capital, int Profit)>();for(int i = 0;i < Profits.Length;i++){projects.Add((Capital[i], Profits[i]));}projects = projects.OrderBy(p => p.Capital).ToList();List<(int Capital, int Profit)> availableProjects = new List<(int Capital, int Profit)>();int index = 0;for(int i = 0;i < k;i++){while(index < projects.Count && projects[index].Capital <= W){availableProjects.Add(projects[index]);index++;}if(!availableProjects.Any()) break;var maxProfitProject = availableProjects.OrderByDescending(p => p.Profit).First();W += maxProfitProject.Profit;availableProjects.Remove(maxProfitProject);}return W;}
public class Solution{public IList<string> FindWords(char[][] board, string[] words){List<string> res = new List<string>();TrieNode root = BuildTrie(words);for(int i = 0;i < board.Length;i++){for(int j = 0;j < board[0].Length;j++){Dfs(board, i, j, root, res);}}return res;}public void Dfs(char[][] board, int i, int j, TrieNode p, List<string> res){char c = board[i][j];if(c == '#' || p.Next[c - 'a'] == null) return;p = p.Next[c - 'a'];if(p.Word != null){res.Add(p.Word);p.Word = null;}board[i][j] = '#';if(i > 0) Dfs(board, i - 1, j, p, res);if(j > 0) Dfs(board, i, j - 1, p, res);if(i < board.Length - 1) Dfs(board, i + 1, j, p, res);if(j < board[0].Length - 1) Dfs(board, i, j + 1, p, res);board[i][j] = c;}public TrieNode BuildTrie(string[] words){TrieNode root = new TrieNode();foreach(string w in words){TrieNode p = root;foreach(char c in w){int i = c - 'a';if(p.Next[i] == null) p.Next[i] = new TrieNode();p = p.Next[i];}p.Word = w;}return root;}}public class TrieNode{public TrieNode[] Next = new TrieNode[26];public string Word;}
public int Calculate(string s){Stack<int> stack = new Stack<int>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.Length;i++){char c = s[i];if(char.IsDigit(c)){number = 10 * number +(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '('){stack.Push(result);stack.Push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.Pop();result += stack.Pop();}}if(number != 0) result += sign * number;return result;}
public IEnumerable<TreeNode> TopSort(TreeNode root){LinkedList<TreeNode> result = new LinkedList<TreeNode>();if(root != null){LinkedList<TreeNode> stack = new LinkedList<TreeNode>();stack.AddFirst(root);while(stack.Count > 0){TreeNode curr = stack.First.Value;stack.RemoveFirst();result.AddFirst(curr);if(curr.right != null) stack.AddFirst(curr.right);if(curr.left != null) stack.AddFirst(curr.left);}}return result;}
public int MaxPathSum(TreeNode root){int result = int.MinValue;Dictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode, int>();maxRootPath[null] = 0;foreach(TreeNode node in TopSort(root)){int left = Math.Max(maxRootPath.GetValueOrDefault(node.left, 0), 0);int right = Math.Max(maxRootPath.GetValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.Max(left, right) + node.val;result = Math.Max(left + right + node.val, result);}return result;}
