public int MinimumTotal(IList<IList<int>> triangle){int n = triangle.Count;int[][] dp = new int[n + 1][];for(int i = 0;i <= n;i++){dp[i] = new int[n + 1];}for(int level = n - 1;level >= 0;level--){for(int i = 0;i <= level;i++){dp[level][i] = triangle[level][i] + Math.Min(dp[level + 1][i], dp[level + 1][i + 1]);}}return dp[0][0];}
public string FractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.Append((numerator > 0) ^(denominator > 0) ? "-" : "");long num = System.Math.Abs((long)numerator);long den = System.Math.Abs((long)denominator);res.Append(num / den);num %= den;if(num == 0){return res.ToString();}res.Append(".");Dictionary<long, int> map = new Dictionary<long, int>();map.Add(num, res.Length);while(num != 0){num *= 10;res.Append(num / den);num %= den;if(map.ContainsKey(num)){int index = map[num];res.Insert(index, "(");res.Append(")");break;}else{map.Add(num, res.Length);}}return res.ToString();}
public int LongestConsecutive(int[] num){int res = 0;Dictionary<int, int> map = new Dictionary<int, int>();foreach(int n in num){if(!map.ContainsKey(n)){int left = map.ContainsKey(n - 1) ? map[n - 1] : 0;int right = map.ContainsKey(n + 1) ? map[n + 1] : 0;int sum = left + right + 1;map[n] = sum;res = System.Math.Max(res, sum);map[n - left] = sum;map[n + right] = sum;}}return res;}
public IList<string> GenerateParenthesis(int n){HashSet<string> allCombos = new HashSet<string>();for(int i = 0;i < n;i++){if(allCombos.Count == 0){allCombos.Add("()");}else{HashSet<string> combos = new HashSet<string>();foreach(string combo in allCombos){combos.Add(combo + "()");combos.Add("()" + combo);for(int j = 0;j < combo.Length - 1;j++){if(combo[j] == '(' && combo[j + 1] == ')'){combos.Add(combo.Substring(0, j + 1) + "()" + combo.Substring(j + 1));combos.Add(combo.Substring(0, j + 1) + ")(" + combo.Substring(j + 1));}}}allCombos = combos;}}return new List<string>(allCombos);}
public int MinDistance(string word1, string word2){int m = word1.Length;int n = word2.Length;int[,] cost = new int[m + 1, n + 1];for(int i = 0;i <= m;i++) cost[i, 0] = i;for(int i = 1;i <= n;i++) cost[0, i] = i;for(int i = 0;i < m;i++){for(int j = 0;j < n;j++){if(word1[i] == word2[j]) cost[i + 1, j + 1] = cost[i, j];else{int a = cost[i, j];int b = cost[i, j + 1];int c = cost[i + 1, j];cost[i + 1, j + 1] = Math.Min(a, Math.Min(b, c)) + 1;}}}return cost[m, n];}
public class WordDictionary{private WordDictionary[] children;private bool isEndOfWord;public WordDictionary(){children = new WordDictionary[26];isEndOfWord = false;}public void AddWord(string word){WordDictionary curr = this;foreach(char c in word){if(curr.children[c - 'a'] == null) curr.children[c - 'a'] = new WordDictionary();curr = curr.children[c - 'a'];}curr.isEndOfWord = true;}public bool Search(string word){return Search(word, 0, this);}private bool Search(string word, int index, WordDictionary node){if(node == null) return false;if(index == word.Length) return node.isEndOfWord;char c = word[index];if(c == '.'){foreach(WordDictionary child in node.children){if(child != null && Search(word, index + 1, child)) return true;}return false;}else{return Search(word, index + 1, node.children[c - 'a']);}}}
public int MaximalSquare(char[][] a){if(a.Length == 0) return 0;int m = a.Length, n = a[0].Length, result = 0;int[,] b = new int[m + 1, n + 1];for(int i = 1;i <= m;i++){for(int j = 1;j <= n;j++){if(a[i - 1][j - 1] == '1'){b[i, j] = Math.Min(Math.Min(b[i, j - 1], b[i - 1, j - 1]), b[i - 1, j]) + 1;result = Math.Max(b[i, j], result);}}}return result * result;}
public class Solution{public IList<IList<int>> ZigzagLevelOrder(TreeNode root){IList<IList<int>> sol = new List<IList<int>>();Travel(root, sol, 0);return sol;}private void Travel(TreeNode curr, IList<IList<int>> sol, int level){if(curr == null) return;if(sol.Count <= level){IList<int> newLevel = new List<int>();sol.Add(newLevel);}IList<int> collection = sol[level];if(level % 2 == 0) collection.Add(curr.val);else collection.Insert(0, curr.val);Travel(curr.left, sol, level + 1);Travel(curr.right, sol, level + 1);}}
public class Solution{public bool IsValidBST(TreeNode root){return IsValidBST(root, long.MinValue, long.MaxValue);}public bool IsValidBST(TreeNode root, long minVal, long maxVal){if(root == null) return true;if(root.val >= maxVal || root.val <= minVal) return false;return IsValidBST(root.left, minVal, root.val) && IsValidBST(root.right, root.val, maxVal);}}
public int[] FindOrder(int numCourses, int[][] prerequisites){if(numCourses == 0) return null;int[] indegree = new int[numCourses], order = new int[numCourses];int index = 0;for(int i = 0;i < prerequisites.Length;i++) indegree[prerequisites[i][0]]++;Queue<int> queue = new Queue<int>();for(int i = 0;i < numCourses;i++) if(indegree[i] == 0){order[index++] = i;queue.Enqueue(i);}while(queue.Count > 0){int prerequisite = queue.Dequeue();for(int i = 0;i < prerequisites.Length;i++){if(prerequisites[i][1] == prerequisite){indegree[prerequisites[i][0]]--;if(indegree[prerequisites[i][0]] == 0){order[index++] = prerequisites[i][0];queue.Enqueue(prerequisites[i][0]);}}}}return(index == numCourses) ? order : new int[0];}
public class Solution{private Dictionary<int, Node> map = new Dictionary<int, Node>();public Node CloneGraph(Node node){return Clone(node);}private Node Clone(Node node){if(node == null) return null;if(map.ContainsKey(node.val)) return map[node.val];Node newNode = new Node(node.val, new List<Node>());map.Add(newNode.val, newNode);foreach(Node neighbor in node.neighbors) newNode.neighbors.Add(Clone(neighbor));return newNode;}}
public int NumIslands(char[][] grid){if(grid == null || grid.Length == 0 || grid[0].Length == 0){return 0;}int H = grid.Length;int W = grid[0].Length;int answer = 0;bool[,] vis = new bool[H, W];int[][] directions = new int[][]{new int[]{1, 0}, new int[]{0, 1}, new int[]{-1, 0}, new int[]{0, -1}};for(int row = 0;row < H;++row){for(int col = 0;col < W;++col){if(!vis[row, col] && grid[row][col] == '1'){answer++;Queue<int[]> q = new Queue<int[]>();q.Enqueue(new int[]{row, col});vis[row, col] = true;while(q.Count > 0){int[] p = q.Dequeue();foreach(int[] dir in directions){int newRow = p[0] + dir[0];int newCol = p[1] + dir[1];if(newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !vis[newRow, newCol] && grid[newRow][newCol] == '1'){q.Enqueue(new int[]{newRow, newCol});vis[newRow, newCol] = true;}}}}}}return answer;}
public int SnakesAndLadders(int[][] board){int n = board.Length;Queue<int> queue = new Queue<int>();queue.Enqueue(1);bool[] visited = new bool[n * n + 1];for(int move = 0;!queue.Count.Equals(0);move++){for(int size = queue.Count;size > 0;size--){int num = queue.Dequeue();if(visited[num]) continue;visited[num] = true;if(num == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n;i++){int next = num + i;int value = GetBoardValue(board, next);if(value > 0) next = value;if(!visited[next]) queue.Enqueue(next);}}}return -1;}private int GetBoardValue(int[][] board, int num){int n = board.Length;int r =(num - 1) / n;int x = n - 1 - r;int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;return board[x][y];}
public int MinMutation(string start, string end, string[] bank){if(start.Equals(end)) return 0;HashSet<string> bankSet = new HashSet<string>(bank);char[] charSet = new char[]{'A', 'C', 'G', 'T'};int level = 0;HashSet<string> visited = new HashSet<string>();Queue<string> queue = new Queue<string>();queue.Enqueue(start);visited.Add(start);while(queue.Count > 0){int size = queue.Count;while(size-- > 0){string curr = queue.Dequeue();if(curr.Equals(end)) return level;char[] currArray = curr.ToCharArray();for(int i = 0;i < currArray.Length;i++){char old = currArray[i];foreach(char c in charSet){currArray[i] = c;string next = new string(currArray);if(!visited.Contains(next) && bankSet.Contains(next)){visited.Add(next);queue.Enqueue(next);}}currArray[i] = old;}}level++;}return -1;}
public int LadderLength(string beginWord, string endWord, IList<string> wordList){if(!wordList.Contains(endWord)){return 0;}HashSet<string> dict = new HashSet<string>(wordList);HashSet<string> beginSet = new HashSet<string>(), endSet = new HashSet<string>();beginSet.Add(beginWord);endSet.Add(endWord);int step = 1;HashSet<string> visited = new HashSet<string>();while(beginSet.Count > 0 && endSet.Count > 0){if(beginSet.Count > endSet.Count){var set = beginSet;beginSet = endSet;endSet = set;}HashSet<string> temp = new HashSet<string>();foreach(string word in beginSet){char[] chs = word.ToCharArray();for(int i = 0;i < chs.Length;i++){for(char c = 'a';c <= 'z';c++){char old = chs[i];chs[i] = c;string target = new string(chs);if(endSet.Contains(target)){return step + 1;}if(!visited.Contains(target) && dict.Contains(target)){temp.Add(target);visited.Add(target);}chs[i] = old;}}}beginSet = temp;step++;}return 0;}
public class LRUCache{class DLinkedNode{public int key;public int value;public DLinkedNode prev;public DLinkedNode next;}private void AddNode(DLinkedNode node){node.prev = head;node.next = head.next;head.next.prev = node;head.next = node;}private void RemoveNode(DLinkedNode node){DLinkedNode prev = node.prev;DLinkedNode next = node.next;prev.next = next;next.prev = prev;}private void MoveToHead(DLinkedNode node){RemoveNode(node);AddNode(node);}private DLinkedNode PopTail(){DLinkedNode res = tail.prev;RemoveNode(res);return res;}private Dictionary<int, DLinkedNode> cache = new Dictionary<int, DLinkedNode>();private int count;private int capacity;private DLinkedNode head, tail;public LRUCache(int capacity){this.count = 0;this.capacity = capacity;head = new DLinkedNode();head.prev = null;tail = new DLinkedNode();tail.next = null;head.next = tail;tail.prev = head;}public int Get(int key){if(!cache.ContainsKey(key)){return -1;}DLinkedNode node = cache[key];MoveToHead(node);return node.value;}public void Put(int key, int value){if(!cache.ContainsKey(key)){DLinkedNode newNode = new DLinkedNode();newNode.key = key;newNode.value = value;cache[key] = newNode;AddNode(newNode);++count;if(count > capacity){DLinkedNode tail = PopTail();cache.Remove(tail.key);--count;}}else{DLinkedNode node = cache[key];node.value = value;MoveToHead(node);}}}
