public void Merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Array.Sort(nums1);}
public IList<double> AverageOfLevels(TreeNode root){List<double> result = new List<double>();Queue<TreeNode> q = new Queue<TreeNode>();if(root == null) return result;q.Enqueue(root);while(q.Count > 0){int n = q.Count;double sum = 0.0;for(int i = 0;i < n;i++){TreeNode node = q.Dequeue();sum += node.val;if(node.left != null) q.Enqueue(node.left);if(node.right != null) q.Enqueue(node.right);}result.Add(sum / n);}return result;}
public class Solution{int minDiff = int.MaxValue;TreeNode prev;public int GetMinimumDifference(TreeNode root){Inorder(root);return minDiff;}public void Inorder(TreeNode root){if(root == null) return;Inorder(root.left);if(prev != null) minDiff = Math.Min(minDiff, root.val - prev.val);prev = root;Inorder(root.right);}}
public bool IsAnagram(string s, string t){int[] alphabet = new int[26];for(int i = 0;i < s.Length;i++) alphabet[s[i] - 'a']++;for(int i = 0;i < t.Length;i++) alphabet[t[i] - 'a']--;foreach(int i in alphabet) if(i != 0) return false;return true;}
public List<string> SummaryRanges(int[] nums){List<string> ranges = new List<string>();for(int i = 0;i < nums.Length;i++){int start = nums[i];while(i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]){i++;}if(start != nums[i]){ranges.Add(start + "->" + nums[i]);}else{ranges.Add(start.ToString());}}return ranges;}
public bool IsValid(string s){Stack<char> stack = new Stack<char>();foreach(char c in s){if(c == '(') stack.Push(')');else if(c == '{') stack.Push('}');else if(c == '[') stack.Push(']');else if(stack.Count == 0 || stack.Pop() != c) return false;}return stack.Count == 0;}
public bool HasCycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.next != null){slow = slow.next;fast = fast.next.next;if(slow == fast) return true;}return false;}
public ListNode MergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNode handler = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handler.next = l1;l1 = l1.next;}else{handler.next = l2;l2 = l2.next;}handler = handler.next;}if(l1 != null){handler.next = l1;}else if(l2 != null){handler.next = l2;}return head.next;}
public class Solution{public bool RootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null) return false;if(root.left == null && root.right == null){sum += root.val;if(sum == targetSum) return true;}return RootToLeafPathSum(root.left, targetSum, sum + root.val) || RootToLeafPathSum(root.right, targetSum, sum + root.val);}public bool HasPathSum(TreeNode root, int targetSum){int sum = 0;return RootToLeafPathSum(root, targetSum, sum);}}
