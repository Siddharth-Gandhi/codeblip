public List<String> findWords(char[][] board, String[] words){List<String> res = new ArrayList<>();TrieNode root = buildTrie(words);for(int i = 0;i < board.length;i++){for(int j = 0;j < board[0].length;j++){dfs(board, i, j, root, res);}}return res;}public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res){char c = board[i][j];if(c == '#' || p.next[c - 'a'] == null) return;p = p.next[c - 'a'];if(p.word != null){res.add(p.word);p.word = null;}board[i][j] = '#';if(i > 0) dfs(board, i - 1, j ,p, res);if(j > 0) dfs(board, i, j - 1, p, res);if(i < board.length - 1) dfs(board, i + 1, j, p, res);if(j < board[0].length - 1) dfs(board, i, j + 1, p, res);board[i][j] = c;}public TrieNode buildTrie(String[] words){TrieNode root = new TrieNode();for(String w : words){TrieNode p = root;for(char c : w.toCharArray()){int i = c - 'a';if(p.next[i] == null) p.next[i] = new TrieNode();p = p.next[i];}p.word = w;}return root;}class TrieNode{TrieNode[] next = new TrieNode[26];String word;}
class WordDictionary{private WordDictionary[] children;boolean isEndOfWord;public WordDictionary(){children = new WordDictionary[26];isEndOfWord = false;}public void addWord(String word){WordDictionary curr = this;for(char c: word.toCharArray()){if(curr.children[c - 'a'] == null) curr.children[c - 'a'] = new WordDictionary();curr = curr.children[c - 'a'];}curr.isEndOfWord = true;}public boolean search(String word){WordDictionary curr = this;for(int i = 0;i < word.length();++i){char c = word.charAt(i);if(c == '.'){for(WordDictionary ch: curr.children) if(ch != null && ch.search(word.substring(i+1))) return true;return false;}if(curr.children[c - 'a'] == null) return false;curr = curr.children[c - 'a'];}return curr != null && curr.isEndOfWord;}}
public class Solution{public List<List<Integer>> zigzagLevelOrder(TreeNode root){List<List<Integer>> sol = new ArrayList<>();travel(root, sol, 0);return sol;}private void travel(TreeNode curr, List<List<Integer>> sol, int level){if(curr == null) return;if(sol.size() <= level){List<Integer> newLevel = new LinkedList<>();sol.add(newLevel);}List<Integer> collection = sol.get(level);if(level % 2 == 0) collection.add(curr.val);else collection.add(0, curr.val);travel(curr.left, sol, level + 1);travel(curr.right, sol, level + 1);}}
public class Solution{public boolean isValidBST(TreeNode root){return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}public boolean isValidBST(TreeNode root, long minVal, long maxVal){if(root == null) return true;if(root.val >= maxVal || root.val <= minVal) return false;return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);}}
public class Solution{int minDiff = Integer.MAX_VALUE;TreeNode prev;public int getMinimumDifference(TreeNode root){inorder(root);return minDiff;}public void inorder(TreeNode root){if(root == null) return;inorder(root.left);if(prev != null) minDiff = Math.min(minDiff, root.val - prev.val);prev = root;inorder(root.right);}}
class Solution{public HashMap<Integer, Node> map = new HashMap<>();public Node cloneGraph(Node node){return clone(node);}public Node clone(Node node){if(node == null) return null;if(map.containsKey(node.val)) return map.get(node.val);Node newNode = new Node(node.val, new ArrayList<Node>());map.put(newNode.val, newNode);for(Node neighbor : node.neighbors) newNode.neighbors.add(clone(neighbor));return newNode;}}
public int snakesAndLadders(int[][] board){int n = board.length;Queue<Integer> queue = new LinkedList<>();queue.offer(1);boolean[] visited = new boolean[n * n + 1];for(int move = 0;!queue.isEmpty();move++){for(int size = queue.size();size > 0;size--){int num = queue.poll();if(visited[num]) continue;visited[num] = true;if(num == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n;i++){int next = num + i;int value = getBoardValue(board, next);if(value > 0) next = value;if(!visited[next]) queue.offer(next);}}}return -1;}private int getBoardValue(int[][] board, int num){int n = board.length;int r =(num - 1) / n;int x = n - 1 - r;int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;return board[x][y];}
import java.util.Hashtable;public class LRUCache{class DLinkedNode{int key;int value;DLinkedNode pre;DLinkedNode post;}private void addNode(DLinkedNode node){node.pre = head;node.post = head.post;head.post.pre = node;head.post = node;}private void removeNode(DLinkedNode node){DLinkedNode pre = node.pre;DLinkedNode post = node.post;pre.post = post;post.pre = pre;}private void moveToHead(DLinkedNode node){this.removeNode(node);this.addNode(node);}private DLinkedNode popTail(){DLinkedNode res = tail.pre;this.removeNode(res);return res;}private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>();private int count;private int capacity;private DLinkedNode head, tail;public LRUCache(int capacity){this.count = 0;this.capacity = capacity;head = new DLinkedNode();head.pre = null;tail = new DLinkedNode();tail.post = null;head.post = tail;tail.pre = head;}public int get(int key){DLinkedNode node = cache.get(key);if(node == null){return -1;}this.moveToHead(node);return node.value;}public void put(int key, int value){DLinkedNode node = cache.get(key);if(node == null){DLinkedNode newNode = new DLinkedNode();newNode.key = key;newNode.value = value;this.cache.put(key, newNode);this.addNode(newNode);++count;if(count > capacity){DLinkedNode tail = this.popTail();this.cache.remove(tail.key);--count;}}else{node.value = value;this.moveToHead(node);}}}
class Solution{public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null) return false;if(root.left == null && root.right == null){sum = sum + root.val;if(sum == targetSum) return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);}public boolean hasPathSum(TreeNode root, int targetSum){int sum = 0;return rootToLeafPathSum(root, targetSum, sum);}}
