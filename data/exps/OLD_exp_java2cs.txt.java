public void merge(int[] nums1, int m, int[] nums2, int n) { for (int j = 0, i = m; j < n; j++) { nums1[i] = nums2[j]; i++; } Arrays.sort(nums1); }
public int minimumTotal(List<List<Integer>> triangle) { int n = triangle.size(); int[][] dp = new int[n+1][n+1]; for (int level=n-1; level>=0; level--) for (int i=0; i<=level; i++) dp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]); return dp[0][0]; }
public int maxProfit(int k, int[] prices) { int n = prices.length; if (n <= 1) return 0; if (k >= n/2) { int maxPro = 0; for (int i = 1; i < n; i++) { if (prices[i] > prices[i-1]) maxPro += prices[i] - prices[i-1]; } return maxPro; } int[][] dp = new int[k+1][n]; for (int i = 1; i <= k; i++) { int localMax = dp[i-1][0] - prices[0]; for (int j = 1; j < n; j++) { dp[i][j] = Math.max(dp[i][j-1], prices[j] + localMax); localMax = Math.max(localMax, dp[i-1][j] - prices[j]); } } return dp[k][n-1]; }
public String fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { return "0"; } StringBuilder res = new StringBuilder(); res.append(((numerator > 0) ^ (denominator > 0)) ? "-" : ""); long num = Math.abs((long)numerator); long den = Math.abs((long)denominator); res.append(num / den); num %= den; if (num == 0) { return res.toString(); } res.append("."); HashMap<Long, Integer> map = new HashMap<Long, Integer>(); map.put(num, res.length()); while (num != 0) { num *= 10; res.append(num / den); num %= den; if (map.containsKey(num)) { int index = map.get(num); res.insert(index, "("); res.append(")"); break; } else { map.put(num, res.length()); } } return res.toString(); }
public int longestConsecutive(int[] num) { int res = 0; HashMap<Integer, Integer> map = new HashMap<Integer, Integer>(); for (int n : num) { if (!map.containsKey(n)) { int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0; int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0; int sum = left + right + 1; map.put(n, sum); res = Math.max(res, sum); map.put(n - left, sum); map.put(n + right, sum); } else { continue; } } return res; }
public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) { PriorityQueue<int[]> pqCap = new PriorityQueue<>((a, b) -> (a[0] - b[0])); PriorityQueue<int[]> pqPro = new PriorityQueue<>((a, b) -> (b[1] - a[1])); for (int i = 0; i < Profits.length; i++) { pqCap.add(new int[] {Capital[i], Profits[i]}); } for (int i = 0; i < k; i++) { while (!pqCap.isEmpty() && pqCap.peek()[0] <= W) { pqPro.add(pqCap.poll()); } if (pqPro.isEmpty()) break; W += pqPro.poll()[1]; } return W; }
public List<String> generateParenthesis(int n) { HashSet<String> allCombos = new HashSet<>(); for(int i=0;i<n;i++){ if(allCombos.size()==0){ allCombos.add("()"); } else{ HashSet<String> combos = new HashSet<>(); for(String combo : allCombos){ combos.add(combo+"()"); combos.add("()"+combo); for(int j=0;j<combo.length()-1;j++){ if(combo.charAt(j)=='(' && combo.charAt(j+1)==')'){ combos.add(combo.substring(0,j+1)+"()"+combo.substring(j+1)); combos.add(combo.substring(0,j+1)+")("+combo.substring(j+1)); } } } allCombos = combos; } } return new ArrayList<String>(allCombos); }
public List<String> findWords(char[][] board, String[] words) { List<String> res = new ArrayList<>(); TrieNode root = buildTrie(words); for (int i = 0; i < board.length; i++) { for (int j = 0; j < board[0].length; j++) { dfs (board, i, j, root, res); } } return res; } public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) { char c = board[i][j]; if (c == '#' || p.next[c - 'a'] == null) return; p = p.next[c - 'a']; if (p.word != null) { res.add(p.word); p.word = null; } board[i][j] = '#'; if (i > 0) dfs(board, i - 1, j ,p, res); if (j > 0) dfs(board, i, j - 1, p, res); if (i < board.length - 1) dfs(board, i + 1, j, p, res); if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); board[i][j] = c; } public TrieNode buildTrie(String[] words) { TrieNode root = new TrieNode(); for (String w : words) { TrieNode p = root; for (char c : w.toCharArray()) { int i = c - 'a'; if (p.next[i] == null) p.next[i] = new TrieNode(); p = p.next[i]; } p.word = w; } return root; } class TrieNode { TrieNode[] next = new TrieNode[26]; String word; }
public int minDistance(String word1, String word2) { int m = word1.length(); int n = word2.length(); int[][] cost = new int[m + 1][n + 1]; for(int i = 0; i <= m; i++) cost[i][0] = i; for(int i = 1; i <= n; i++) cost[0][i] = i; for(int i = 0; i < m; i++) { for(int j = 0; j < n; j++) { if(word1.charAt(i) == word2.charAt(j)) cost[i + 1][j + 1] = cost[i][j]; else { int a = cost[i][j]; int b = cost[i][j + 1]; int c = cost[i + 1][j]; cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c); cost[i + 1][j + 1]++; } } } return cost[m][n]; }
class WordDictionary { private WordDictionary[] children; boolean isEndOfWord; public WordDictionary() { children = new WordDictionary[26]; isEndOfWord = false; } public void addWord(String word) { WordDictionary curr = this; for(char c: word.toCharArray()){ if(curr.children[c - 'a'] == null) curr.children[c - 'a'] = new WordDictionary(); curr = curr.children[c - 'a']; } curr.isEndOfWord = true; } public boolean search(String word) { WordDictionary curr = this; for(int i = 0; i < word.length(); ++i){ char c = word.charAt(i); if(c == '.'){ for(WordDictionary ch: curr.children) if(ch != null && ch.search(word.substring(i+1))) return true; return false; } if(curr.children[c - 'a'] == null) return false; curr = curr.children[c - 'a']; } return curr != null && curr.isEndOfWord; } }
public int maximalSquare(char[][] a) { if(a.length == 0) return 0; int m = a.length, n = a[0].length, result = 0; int[][] b = new int[m+1][n+1]; for (int i = 1 ; i <= m; i++) { for (int j = 1; j <= n; j++) { if(a[i-1][j-1] == '1') { b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1; result = Math.max(b[i][j], result); } } } return result*result; }
public class Solution { public List<List<Integer>> zigzagLevelOrder(TreeNode root) { List<List<Integer>> sol = new ArrayList<>(); travel(root, sol, 0); return sol; } private void travel(TreeNode curr, List<List<Integer>> sol, int level) { if(curr == null) return; if(sol.size() <= level) { List<Integer> newLevel = new LinkedList<>(); sol.add(newLevel); } List<Integer> collection = sol.get(level); if(level % 2 == 0) collection.add(curr.val); else collection.add(0, curr.val); travel(curr.left, sol, level + 1); travel(curr.right, sol, level + 1); } }
public List<Double> averageOfLevels(TreeNode root) { List<Double> result = new ArrayList<>(); Queue<TreeNode> q = new LinkedList<>(); if(root == null) return result; q.add(root); while(!q.isEmpty()) { int n = q.size(); double sum = 0.0; for(int i = 0; i < n; i++) { TreeNode node = q.poll(); sum += node.val; if(node.left != null) q.offer(node.left); if(node.right != null) q.offer(node.right); } result.add(sum / n); } return result; }
public class Solution { public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } public boolean isValidBST(TreeNode root, long minVal, long maxVal) { if (root == null) return true; if (root.val >= maxVal || root.val <= minVal) return false; return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal); } }
public int[] findOrder(int numCourses, int[][] prerequisites) { if (numCourses == 0) return null; int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0; for (int i = 0; i < prerequisites.length; i++) indegree[prerequisites[i][0]]++; Queue<Integer> queue = new LinkedList<Integer>(); for (int i = 0; i < numCourses; i++) if (indegree[i] == 0) { order[index++] = i; queue.offer(i); } while (!queue.isEmpty()) { int prerequisite = queue.poll(); for (int i = 0; i < prerequisites.length; i++) { if (prerequisites[i][1] == prerequisite) { indegree[prerequisites[i][0]]--; if (indegree[prerequisites[i][0]] == 0) { order[index++] = prerequisites[i][0]; queue.offer(prerequisites[i][0]); } } } } return (index == numCourses) ? order : new int[0]; }
public class Solution { int minDiff = Integer.MAX_VALUE; TreeNode prev; public int getMinimumDifference(TreeNode root) { inorder(root); return minDiff; } public void inorder(TreeNode root) { if (root == null) return; inorder(root.left); if (prev != null) minDiff = Math.min(minDiff, root.val - prev.val); prev = root; inorder(root.right); } }
class Solution { public HashMap<Integer, Node> map = new HashMap<>(); public Node cloneGraph(Node node) { return clone(node); } public Node clone(Node node) { if (node == null) return null; if (map.containsKey(node.val)) return map.get(node.val); Node newNode = new Node(node.val, new ArrayList<Node>()); map.put(newNode.val, newNode); for (Node neighbor : node.neighbors) newNode.neighbors.add(clone(neighbor)); return newNode; } }
public int numIslands(char[][] grid) { if (grid == null || grid.length == 0 || grid[0].length == 0) { return 0; } int H = grid.length; int W = grid[0].length; int answer = 0; boolean[][] vis = new boolean[H][W]; int[][] directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; for (int row = 0; row < H; ++row) { for (int col = 0; col < W; ++col) { if (!vis[row][col] && grid[row][col] == '1') { answer++; Queue<int[]> q = new LinkedList<>(); q.add(new int[]{row, col}); vis[row][col] = true; while (!q.isEmpty()) { int[] p = q.poll(); for (int[] dir : directions) { int new_row = p[0] + dir[0]; int new_col = p[1] + dir[1]; if (new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !vis[new_row][new_col] && grid[new_row][new_col] == '1') { q.add(new int[]{new_row, new_col}); vis[new_row][new_col] = true; } } } } } } return answer; }
public int snakesAndLadders(int[][] board) { int n = board.length; Queue<Integer> queue = new LinkedList<>(); queue.offer(1); boolean[] visited = new boolean[n * n + 1]; for (int move = 0; !queue.isEmpty(); move++) { for (int size = queue.size(); size > 0; size--) { int num = queue.poll(); if (visited[num]) continue; visited[num] = true; if (num == n * n) return move; for (int i = 1; i <= 6 && num + i <= n * n; i++) { int next = num + i; int value = getBoardValue(board, next); if (value > 0) next = value; if (!visited[next]) queue.offer(next); } } } return -1; } private int getBoardValue(int[][] board, int num) { int n = board.length; int r = (num - 1) / n; int x = n - 1 - r; int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num; return board[x][y]; }
public int minMutation(String start, String end, String[] bank) { if(start.equals(end)) return 0; Set<String> bankSet = new HashSet<>(); for(String b: bank) bankSet.add(b); char[] charSet = new char[]{'A', 'C', 'G', 'T'}; int level = 0; Set<String> visited = new HashSet<>(); Queue<String> queue = new LinkedList<>(); queue.offer(start); visited.add(start); while(!queue.isEmpty()) { int size = queue.size(); while(size-- > 0) { String curr = queue.poll(); if(curr.equals(end)) return level; char[] currArray = curr.toCharArray(); for(int i = 0; i < currArray.length; i++) { char old = currArray[i]; for(char c: charSet) { currArray[i] = c; String next = new String(currArray); if(!visited.contains(next) && bankSet.contains(next)) { visited.add(next); queue.offer(next); } } currArray[i] = old; } } level++; } return -1; }
public int ladderLength(String beginWord, String endWord, List<String> wordList) { if (!wordList.contains(endWord)) { return 0; } Set<String> dict = new HashSet<>(wordList); Set<String> beginSet = new HashSet<>(); Set<String> endSet = new HashSet<>(); beginSet.add(beginWord); endSet.add(endWord); int step = 1; Set<String> visited = new HashSet<>(); while (!beginSet.isEmpty() && !endSet.isEmpty()) { if (beginSet.size() > endSet.size()) { Set<String> set = beginSet; beginSet = endSet; endSet = set; } Set<String> temp = new HashSet<>(); for (String word : beginSet) { char[] chs = word.toCharArray(); for (int i = 0; i < chs.length; i++) { for (char c = 'a'; c <= 'z'; c++) { char old = chs[i]; chs[i] = c; String target = String.valueOf(chs); if (endSet.contains(target)) { return step + 1; } if (!visited.contains(target) && dict.contains(target)) { temp.add(target); visited.add(target); } chs[i] = old; } } } beginSet = temp; step++; } return 0; }
public int calculate(String s) { Stack<Integer> stack = new Stack<Integer>(); int result = 0; int number = 0; int sign = 1; for(int i = 0; i < s.length(); i++){ char c = s.charAt(i); if(Character.isDigit(c)){ number = 10 * number + (int)(c - '0'); }else if(c == '+'){ result += sign * number; number = 0; sign = 1; }else if(c == '-'){ result += sign * number; number = 0; sign = -1; }else if(c == '('){ stack.push(result); stack.push(sign); sign = 1; result = 0; }else if(c == ')'){ result += sign * number; number = 0; result *= stack.pop(); result += stack.pop(); } } if(number != 0) result += sign * number; return result; }
public boolean isAnagram(String s, String t) { int[] alphabet = new int[26]; for (int i = 0; i < s.length(); i++) alphabet[s.charAt(i) - 'a']++; for (int i = 0; i < t.length(); i++) alphabet[t.charAt(i) - 'a']--; for (int i : alphabet) if (i != 0) return false; return true; }
public List<String> summaryRanges(int[] nums) { ArrayList<String> al=new ArrayList<>(); for(int i=0;i<nums.length;i++){ int start=nums[i]; while(i+1<nums.length && nums[i]+1==nums[i+1]) i++; if(start!=nums[i]){ al.add(""+start+"->"+nums[i]); } else{ al.add(""+start); } } return al; }
public boolean isValid(String s) { Stack<Character> stack = new Stack<Character>(); for (char c : s.toCharArray()) { if (c == '(') stack.push(')'); else if (c == '{') stack.push('}'); else if (c == '[') stack.push(']'); else if (stack.isEmpty() || stack.pop() != c) return false; } return stack.isEmpty(); }
public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; }
public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(0); ListNode handler = head; while(l1 != null && l2 != null) { if (l1.val <= l2.val) { handler.next = l1; l1 = l1.next; } else { handler.next = l2; l2 = l2.next; } handler = handler.next; } if (l1 != null) { handler.next = l1; } else if (l2 != null) { handler.next = l2; } return head.next; }
import java.util.Hashtable; public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode pre; DLinkedNode post; } private void addNode(DLinkedNode node) { node.pre = head; node.post = head.post; head.post.pre = node; head.post = node; } private void removeNode(DLinkedNode node){ DLinkedNode pre = node.pre; DLinkedNode post = node.post; pre.post = post; post.pre = pre; } private void moveToHead(DLinkedNode node){ this.removeNode(node); this.addNode(node); } private DLinkedNode popTail(){ DLinkedNode res = tail.pre; this.removeNode(res); return res; } private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>(); private int count; private int capacity; private DLinkedNode head, tail; public LRUCache(int capacity) { this.count = 0; this.capacity = capacity; head = new DLinkedNode(); head.pre = null; tail = new DLinkedNode(); tail.post = null; head.post = tail; tail.pre = head; } public int get(int key) { DLinkedNode node = cache.get(key); if(node == null){ return -1; } this.moveToHead(node); return node.value; } public void put(int key, int value) { DLinkedNode node = cache.get(key); if(node == null){ DLinkedNode newNode = new DLinkedNode(); newNode.key = key; newNode.value = value; this.cache.put(key, newNode); this.addNode(newNode); ++count; if(count > capacity){ DLinkedNode tail = this.popTail(); this.cache.remove(tail.key); --count; } }else{ node.value = value; this.moveToHead(node); } } }
class Solution { public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){ if(root == null) return false; if(root.left == null && root.right == null){ sum = sum + root.val; if(sum == targetSum) return true; } return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val); } public boolean hasPathSum(TreeNode root, int targetSum) { int sum = 0; return rootToLeafPathSum(root, targetSum, sum); } }
public Iterable<TreeNode> topSort(TreeNode root) { Deque<TreeNode> result = new LinkedList<>(); if (root != null) { Deque<TreeNode> stack = new LinkedList<>(); stack.push(root); while (!stack.isEmpty()) { TreeNode curr = stack.pop(); result.push(curr); if (curr.right != null) stack.push(curr.right); if (curr.left != null) stack.push(curr.left); } } return result; }
public int maxPathSum(TreeNode root) { int result = Integer.MIN_VALUE; Map<TreeNode, Integer> maxRootPath = new HashMap<>(); maxRootPath.put(null, 0); for (TreeNode node : topSort(root)) { int left = Math.max(maxRootPath.get(node.left), 0); int right = Math.max(maxRootPath.get(node.right), 0); maxRootPath.put(node, Math.max(left, right) + node.val); result = Math.max(left + right + node.val, result); } return result; }
