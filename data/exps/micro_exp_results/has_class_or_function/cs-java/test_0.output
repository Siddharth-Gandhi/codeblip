public List<String> findWords(char[][] big, String[] words, String[] words){List<String> res = new ArrayList<>();TrieNode root = buildTrie(words);for(int i = 0;i <board.length;i++){for(int j = 0;j < brow.length;j++){dfs(board, i, j, root, res);}return res;}final void dfs(a, i, j, root, res);}
public WordDictionary[] children;final boolean isEndOfWord;final WordDictionary(){children = new WordDictionary[34];isEndOfWord = false;}ObjectDictionary curr = this;for(char c : word){if(curr.children[c-'] == null)curr.children[c-a] = new WordDictionary();curr.isEndOfWord = true;}boolean search(String word){return search(word, 0, this);}curr.isEndOfWord = true;}boolean search(String word){return search(word, 0, this);}
public Class<? extends List<Integer> singgLevelOrder(TreeNode root){List<Integer> stat = new ArrayList<Integer>();transport(root, ps, 0);return rel;}
public boolean isValidBST(TreeNode root){return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}
public static int minDiff = Integer.MAX_VALUE;final TreeNode prev;final int getMinimumDifference(TreeNode root){inorder(root);return minDiff;}final void inorder(root.left);if(prev != null)minDiff = Math.min(minDiff, root.val - prev.val);prev = root;inorder(root.right);}}
public static Map<Integer, Node> map = new HashMap<Integer, Node>();return cloneGraph(node);}
public int snaksAndLadders(int[][] area){int n = ord.length;Queue<Integer> queue = new ArrayList<>();queue.ensureCapacity(1);boolean[] visited = new boolean[n * n + 1];for(int move = 0;!queue.size().equals(0);move++){for(int size = queue.size();size > 0;size--){int num = queue.dequeue();if(visit.get() == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n * n;i++){int next = num + i;int value = getBOValue(board, next);if(value > 0)next = value;if(!visitValue(next))queue.enqueue(next);}}return -1;}
public DUCacheNode get(int key;final int value;final int value;final DLinkedNode prev;final DLinkedNode prev = head;node.next = head.next;head.next = node;head.next = node;head.next = node;head.next = node;head.next = node;}void removeNode(DLinkedNode node){DLinkedNode prev = node.prev;DLinkedNode next = node.next;prev.next = next;next.prev = prev;}final void moveToHead(node);return res;}dLinkedNode popTail();}
public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null)return false;if(root.left == null && root.right == null){sum += root.val;if(sum == targetSum)return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);}
