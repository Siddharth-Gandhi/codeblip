public void Merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Array.Sort(nums1);}
public int MinimumTotal(IList<IList<int>> triangle){int n = triangle.Count;int[][] dp = new int[n + 1][];for(int i = 0;i <= n;i++){dp[i] = new int[n + 1];}for(int level = n - 1;level >= 0;level--){for(int i = 0;i <= level;i++){dp[level][i] = triangle[level][i] + Math.Min(dp[level + 1][i], dp[level + 1][i + 1]);}}return dp[0][0];}
public int MaxProfit(int k, int[] prices){int n = prices.Length;if(n <= 1) return 0;if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(prices[i] > prices[i - 1]) maxPro += prices[i] - prices[i - 1];}return maxPro;}int[,] dp = new int[k + 1, n];for(int i = 1;i <= k;i++){int localMax = dp[i - 1, 0] - prices[0];for(int j = 1;j < n;j++){dp[i, j] = Math.Max(dp[i, j - 1], prices[j] + localMax);localMax = Math.Max(localMax, dp[i - 1, j] - prices[j]);}}return dp[k, n - 1];}
public string FractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.Append((numerator > 0) ^(denominator > 0) ? "-" : "");long num = System.Math.Abs((long)numerator);long den = System.Math.Abs((long)denominator);res.Append(num / den);num %= den;if(num == 0){return res.ToString();}res.Append(".");Dictionary<long, int> map = new Dictionary<long, int>();map.Add(num, res.Length);while(num != 0){num *= 10;res.Append(num / den);num %= den;if(map.ContainsKey(num)){int index = map[num];res.Insert(index, "(");res.Append(")");break;}else{map.Add(num, res.Length);}}return res.ToString();}
public int LongestConsecutive(int[] num){int res = 0;Dictionary<int, int> map = new Dictionary<int, int>();foreach(int n in num){if(!map.ContainsKey(n)){int left = map.ContainsKey(n - 1) ? map[n - 1] : 0;int right = map.ContainsKey(n + 1) ? map[n + 1] : 0;int sum = left + right + 1;map[n] = sum;res = System.Math.Max(res, sum);map[n - left] = sum;map[n + right] = sum;}}return res;}
public int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital){List<(int Capital, int Profit)> projects = new List<(int Capital, int Profit)>();for(int i = 0;i < Profits.Length;i++){projects.Add((Capital[i], Profits[i]));}projects = projects.OrderBy(p => p.Capital).ToList();List<(int Capital, int Profit)> availableProjects = new List<(int Capital, int Profit)>();int index = 0;for(int i = 0;i < k;i++){while(index < projects.Count && projects[index].Capital <= W){availableProjects.Add(projects[index]);index++;}if(!availableProjects.Any()) break;var maxProfitProject = availableProjects.OrderByDescending(p => p.Profit).First();W += maxProfitProject.Profit;availableProjects.Remove(maxProfitProject);}return W;}
public IList<string> GenerateParenthesis(int n){HashSet<string> allCombos = new HashSet<string>();for(int i = 0;i < n;i++){if(allCombos.Count == 0){allCombos.Add("()");}else{HashSet<string> combos = new HashSet<string>();foreach(string combo in allCombos){combos.Add(combo + "()");combos.Add("()" + combo);for(int j = 0;j < combo.Length - 1;j++){if(combo[j] == '(' && combo[j + 1] == ')'){combos.Add(combo.Substring(0, j + 1) + "()" + combo.Substring(j + 1));combos.Add(combo.Substring(0, j + 1) + ")(" + combo.Substring(j + 1));}}}allCombos = combos;}}return new List<string>(allCombos);}
public int MinDistance(string word1, string word2){int m = word1.Length;int n = word2.Length;int[,] cost = new int[m + 1, n + 1];for(int i = 0;i <= m;i++) cost[i, 0] = i;for(int i = 1;i <= n;i++) cost[0, i] = i;for(int i = 0;i < m;i++){for(int j = 0;j < n;j++){if(word1[i] == word2[j]) cost[i + 1, j + 1] = cost[i, j];else{int a = cost[i, j];int b = cost[i, j + 1];int c = cost[i + 1, j];cost[i + 1, j + 1] = Math.Min(a, Math.Min(b, c)) + 1;}}}return cost[m, n];}
public int MaximalSquare(char[][] a){if(a.Length == 0) return 0;int m = a.Length, n = a[0].Length, result = 0;int[,] b = new int[m + 1, n + 1];for(int i = 1;i <= m;i++){for(int j = 1;j <= n;j++){if(a[i - 1][j - 1] == '1'){b[i, j] = Math.Min(Math.Min(b[i, j - 1], b[i - 1, j - 1]), b[i - 1, j]) + 1;result = Math.Max(b[i, j], result);}}}return result * result;}
public IList<double> AverageOfLevels(TreeNode root){List<double> result = new List<double>();Queue<TreeNode> q = new Queue<TreeNode>();if(root == null) return result;q.Enqueue(root);while(q.Count > 0){int n = q.Count;double sum = 0.0;for(int i = 0;i < n;i++){TreeNode node = q.Dequeue();sum += node.val;if(node.left != null) q.Enqueue(node.left);if(node.right != null) q.Enqueue(node.right);}result.Add(sum / n);}return result;}
public int[] FindOrder(int numCourses, int[][] prerequisites){if(numCourses == 0) return null;int[] indegree = new int[numCourses], order = new int[numCourses];int index = 0;for(int i = 0;i < prerequisites.Length;i++) indegree[prerequisites[i][0]]++;Queue<int> queue = new Queue<int>();for(int i = 0;i < numCourses;i++) if(indegree[i] == 0){order[index++] = i;queue.Enqueue(i);}while(queue.Count > 0){int prerequisite = queue.Dequeue();for(int i = 0;i < prerequisites.Length;i++){if(prerequisites[i][1] == prerequisite){indegree[prerequisites[i][0]]--;if(indegree[prerequisites[i][0]] == 0){order[index++] = prerequisites[i][0];queue.Enqueue(prerequisites[i][0]);}}}}return(index == numCourses) ? order : new int[0];}
public int NumIslands(char[][] grid){if(grid == null || grid.Length == 0 || grid[0].Length == 0){return 0;}int H = grid.Length;int W = grid[0].Length;int answer = 0;bool[,] vis = new bool[H, W];int[][] directions = new int[][]{new int[]{1, 0}, new int[]{0, 1}, new int[]{-1, 0}, new int[]{0, -1}};for(int row = 0;row < H;++row){for(int col = 0;col < W;++col){if(!vis[row, col] && grid[row][col] == '1'){answer++;Queue<int[]> q = new Queue<int[]>();q.Enqueue(new int[]{row, col});vis[row, col] = true;while(q.Count > 0){int[] p = q.Dequeue();foreach(int[] dir in directions){int newRow = p[0] + dir[0];int newCol = p[1] + dir[1];if(newRow >= 0 && newRow < H && newCol >= 0 && newCol < W && !vis[newRow, newCol] && grid[newRow][newCol] == '1'){q.Enqueue(new int[]{newRow, newCol});vis[newRow, newCol] = true;}}}}}}return answer;}
public int MinMutation(string start, string end, string[] bank){if(start.Equals(end)) return 0;HashSet<string> bankSet = new HashSet<string>(bank);char[] charSet = new char[]{'A', 'C', 'G', 'T'};int level = 0;HashSet<string> visited = new HashSet<string>();Queue<string> queue = new Queue<string>();queue.Enqueue(start);visited.Add(start);while(queue.Count > 0){int size = queue.Count;while(size-- > 0){string curr = queue.Dequeue();if(curr.Equals(end)) return level;char[] currArray = curr.ToCharArray();for(int i = 0;i < currArray.Length;i++){char old = currArray[i];foreach(char c in charSet){currArray[i] = c;string next = new string(currArray);if(!visited.Contains(next) && bankSet.Contains(next)){visited.Add(next);queue.Enqueue(next);}}currArray[i] = old;}}level++;}return -1;}
public int LadderLength(string beginWord, string endWord, IList<string> wordList){if(!wordList.Contains(endWord)){return 0;}HashSet<string> dict = new HashSet<string>(wordList);HashSet<string> beginSet = new HashSet<string>(), endSet = new HashSet<string>();beginSet.Add(beginWord);endSet.Add(endWord);int step = 1;HashSet<string> visited = new HashSet<string>();while(beginSet.Count > 0 && endSet.Count > 0){if(beginSet.Count > endSet.Count){var set = beginSet;beginSet = endSet;endSet = set;}HashSet<string> temp = new HashSet<string>();foreach(string word in beginSet){char[] chs = word.ToCharArray();for(int i = 0;i < chs.Length;i++){for(char c = 'a';c <= 'z';c++){char old = chs[i];chs[i] = c;string target = new string(chs);if(endSet.Contains(target)){return step + 1;}if(!visited.Contains(target) && dict.Contains(target)){temp.Add(target);visited.Add(target);}chs[i] = old;}}}beginSet = temp;step++;}return 0;}
public int Calculate(string s){Stack<int> stack = new Stack<int>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.Length;i++){char c = s[i];if(char.IsDigit(c)){number = 10 * number +(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '('){stack.Push(result);stack.Push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.Pop();result += stack.Pop();}}if(number != 0) result += sign * number;return result;}
public bool IsAnagram(string s, string t){int[] alphabet = new int[26];for(int i = 0;i < s.Length;i++) alphabet[s[i] - 'a']++;for(int i = 0;i < t.Length;i++) alphabet[t[i] - 'a']--;foreach(int i in alphabet) if(i != 0) return false;return true;}
public List<string> SummaryRanges(int[] nums){List<string> ranges = new List<string>();for(int i = 0;i < nums.Length;i++){int start = nums[i];while(i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]){i++;}if(start != nums[i]){ranges.Add(start + "->" + nums[i]);}else{ranges.Add(start.ToString());}}return ranges;}
public bool IsValid(string s){Stack<char> stack = new Stack<char>();foreach(char c in s){if(c == '(') stack.Push(')');else if(c == '{') stack.Push('}');else if(c == '[') stack.Push(']');else if(stack.Count == 0 || stack.Pop() != c) return false;}return stack.Count == 0;}
public bool HasCycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.next != null){slow = slow.next;fast = fast.next.next;if(slow == fast) return true;}return false;}
public ListNode MergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNode handler = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handler.next = l1;l1 = l1.next;}else{handler.next = l2;l2 = l2.next;}handler = handler.next;}if(l1 != null){handler.next = l1;}else if(l2 != null){handler.next = l2;}return head.next;}
public IEnumerable<TreeNode> TopSort(TreeNode root){LinkedList<TreeNode> result = new LinkedList<TreeNode>();if(root != null){LinkedList<TreeNode> stack = new LinkedList<TreeNode>();stack.AddFirst(root);while(stack.Count > 0){TreeNode curr = stack.First.Value;stack.RemoveFirst();result.AddFirst(curr);if(curr.right != null) stack.AddFirst(curr.right);if(curr.left != null) stack.AddFirst(curr.left);}}return result;}
public int MaxPathSum(TreeNode root){int result = int.MinValue;Dictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode, int>();maxRootPath[null] = 0;foreach(TreeNode node in TopSort(root)){int left = Math.Max(maxRootPath.GetValueOrDefault(node.left, 0), 0);int right = Math.Max(maxRootPath.GetValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.Max(left, right) + node.val;result = Math.Max(left + right + node.val, result);}return result;}
