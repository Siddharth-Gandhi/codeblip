public int minimumTotal(List<List<Integer>> triangle){int n = triangle.size();int[][] dp = new int[n+1][n+1];for(int level=n-1;level>=0;level--) for(int i=0;i<=level;i++) dp[level][i] = triangle.get(level).get(i) + Math.min(dp[level+1][i], dp[level+1][i+1]);return dp[0][0];}
public String fractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.append(((numerator > 0) ^(denominator > 0)) ? "-" : "");long num = Math.abs((long)numerator);long den = Math.abs((long)denominator);res.append(num / den);num %= den;if(num == 0){return res.toString();}res.append(".");HashMap<Long, Integer> map = new HashMap<Long, Integer>();map.put(num, res.length());while(num != 0){num *= 10;res.append(num / den);num %= den;if(map.containsKey(num)){int index = map.get(num);res.insert(index, "(");res.append(")");break;}else{map.put(num, res.length());}}return res.toString();}
public int longestConsecutive(int[] num){int res = 0;HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();for(int n : num){if(!map.containsKey(n)){int left =(map.containsKey(n - 1)) ? map.get(n - 1) : 0;int right =(map.containsKey(n + 1)) ? map.get(n + 1) : 0;int sum = left + right + 1;map.put(n, sum);res = Math.max(res, sum);map.put(n - left, sum);map.put(n + right, sum);}else{continue;}}return res;}
public List<String> generateParenthesis(int n){HashSet<String> allCombos = new HashSet<>();for(int i=0;i<n;i++){if(allCombos.size()==0){allCombos.add("()");}else{HashSet<String> combos = new HashSet<>();for(String combo : allCombos){combos.add(combo+"()");combos.add("()"+combo);for(int j=0;j<combo.length()-1;j++){if(combo.charAt(j)=='(' && combo.charAt(j+1)==')'){combos.add(combo.substring(0,j+1)+"()"+combo.substring(j+1));combos.add(combo.substring(0,j+1)+")("+combo.substring(j+1));}}}allCombos = combos;}}return new ArrayList<String>(allCombos);}
public int minDistance(String word1, String word2){int m = word1.length();int n = word2.length();int[][] cost = new int[m + 1][n + 1];for(int i = 0;i <= m;i++) cost[i][0] = i;for(int i = 1;i <= n;i++) cost[0][i] = i;for(int i = 0;i < m;i++){for(int j = 0;j < n;j++){if(word1.charAt(i) == word2.charAt(j)) cost[i + 1][j + 1] = cost[i][j];else{int a = cost[i][j];int b = cost[i][j + 1];int c = cost[i + 1][j];cost[i + 1][j + 1] = a < b ?(a < c ? a : c) :(b < c ? b : c);cost[i + 1][j + 1]++;}}}return cost[m][n];}
class WordDictionary{private WordDictionary[] children;boolean isEndOfWord;public WordDictionary(){children = new WordDictionary[26];isEndOfWord = false;}public void addWord(String word){WordDictionary curr = this;for(char c: word.toCharArray()){if(curr.children[c - 'a'] == null) curr.children[c - 'a'] = new WordDictionary();curr = curr.children[c - 'a'];}curr.isEndOfWord = true;}public boolean search(String word){WordDictionary curr = this;for(int i = 0;i < word.length();++i){char c = word.charAt(i);if(c == '.'){for(WordDictionary ch: curr.children) if(ch != null && ch.search(word.substring(i+1))) return true;return false;}if(curr.children[c - 'a'] == null) return false;curr = curr.children[c - 'a'];}return curr != null && curr.isEndOfWord;}}
public int maximalSquare(char[][] a){if(a.length == 0) return 0;int m = a.length, n = a[0].length, result = 0;int[][] b = new int[m+1][n+1];for(int i = 1 ;i <= m;i++){for(int j = 1;j <= n;j++){if(a[i-1][j-1] == '1'){b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;result = Math.max(b[i][j], result);}}}return result*result;}
public class Solution{public List<List<Integer>> zigzagLevelOrder(TreeNode root){List<List<Integer>> sol = new ArrayList<>();travel(root, sol, 0);return sol;}private void travel(TreeNode curr, List<List<Integer>> sol, int level){if(curr == null) return;if(sol.size() <= level){List<Integer> newLevel = new LinkedList<>();sol.add(newLevel);}List<Integer> collection = sol.get(level);if(level % 2 == 0) collection.add(curr.val);else collection.add(0, curr.val);travel(curr.left, sol, level + 1);travel(curr.right, sol, level + 1);}}
public class Solution{public boolean isValidBST(TreeNode root){return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}public boolean isValidBST(TreeNode root, long minVal, long maxVal){if(root == null) return true;if(root.val >= maxVal || root.val <= minVal) return false;return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);}}
public int[] findOrder(int numCourses, int[][] prerequisites){if(numCourses == 0) return null;int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;for(int i = 0;i < prerequisites.length;i++) indegree[prerequisites[i][0]]++;Queue<Integer> queue = new LinkedList<Integer>();for(int i = 0;i < numCourses;i++) if(indegree[i] == 0){order[index++] = i;queue.offer(i);}while(!queue.isEmpty()){int prerequisite = queue.poll();for(int i = 0;i < prerequisites.length;i++){if(prerequisites[i][1] == prerequisite){indegree[prerequisites[i][0]]--;if(indegree[prerequisites[i][0]] == 0){order[index++] = prerequisites[i][0];queue.offer(prerequisites[i][0]);}}}}return(index == numCourses) ? order : new int[0];}
class Solution{public HashMap<Integer, Node> map = new HashMap<>();public Node cloneGraph(Node node){return clone(node);}public Node clone(Node node){if(node == null) return null;if(map.containsKey(node.val)) return map.get(node.val);Node newNode = new Node(node.val, new ArrayList<Node>());map.put(newNode.val, newNode);for(Node neighbor : node.neighbors) newNode.neighbors.add(clone(neighbor));return newNode;}}
public int numIslands(char[][] grid){if(grid == null || grid.length == 0 || grid[0].length == 0){return 0;}int H = grid.length;int W = grid[0].length;int answer = 0;boolean[][] vis = new boolean[H][W];int[][] directions ={{1, 0},{0, 1},{-1, 0},{0, -1}};for(int row = 0;row < H;++row){for(int col = 0;col < W;++col){if(!vis[row][col] && grid[row][col] == '1'){answer++;Queue<int[]> q = new LinkedList<>();q.add(new int[]{row, col});vis[row][col] = true;while(!q.isEmpty()){int[] p = q.poll();for(int[] dir : directions){int new_row = p[0] + dir[0];int new_col = p[1] + dir[1];if(new_row >= 0 && new_row < H && new_col >= 0 && new_col < W && !vis[new_row][new_col] && grid[new_row][new_col] == '1'){q.add(new int[]{new_row, new_col});vis[new_row][new_col] = true;}}}}}}return answer;}
public int snakesAndLadders(int[][] board){int n = board.length;Queue<Integer> queue = new LinkedList<>();queue.offer(1);boolean[] visited = new boolean[n * n + 1];for(int move = 0;!queue.isEmpty();move++){for(int size = queue.size();size > 0;size--){int num = queue.poll();if(visited[num]) continue;visited[num] = true;if(num == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n;i++){int next = num + i;int value = getBoardValue(board, next);if(value > 0) next = value;if(!visited[next]) queue.offer(next);}}}return -1;}private int getBoardValue(int[][] board, int num){int n = board.length;int r =(num - 1) / n;int x = n - 1 - r;int y = r % 2 == 0 ? num - 1 - r * n : n + r * n - num;return board[x][y];}
public int minMutation(String start, String end, String[] bank){if(start.equals(end)) return 0;Set<String> bankSet = new HashSet<>();for(String b: bank) bankSet.add(b);char[] charSet = new char[]{'A', 'C', 'G', 'T'};int level = 0;Set<String> visited = new HashSet<>();Queue<String> queue = new LinkedList<>();queue.offer(start);visited.add(start);while(!queue.isEmpty()){int size = queue.size();while(size-- > 0){String curr = queue.poll();if(curr.equals(end)) return level;char[] currArray = curr.toCharArray();for(int i = 0;i < currArray.length;i++){char old = currArray[i];for(char c: charSet){currArray[i] = c;String next = new String(currArray);if(!visited.contains(next) && bankSet.contains(next)){visited.add(next);queue.offer(next);}}currArray[i] = old;}}level++;}return -1;}
public int ladderLength(String beginWord, String endWord, List<String> wordList){if(!wordList.contains(endWord)){return 0;}Set<String> dict = new HashSet<>(wordList);Set<String> beginSet = new HashSet<>();Set<String> endSet = new HashSet<>();beginSet.add(beginWord);endSet.add(endWord);int step = 1;Set<String> visited = new HashSet<>();while(!beginSet.isEmpty() && !endSet.isEmpty()){if(beginSet.size() > endSet.size()){Set<String> set = beginSet;beginSet = endSet;endSet = set;}Set<String> temp = new HashSet<>();for(String word : beginSet){char[] chs = word.toCharArray();for(int i = 0;i < chs.length;i++){for(char c = 'a';c <= 'z';c++){char old = chs[i];chs[i] = c;String target = String.valueOf(chs);if(endSet.contains(target)){return step + 1;}if(!visited.contains(target) && dict.contains(target)){temp.add(target);visited.add(target);}chs[i] = old;}}}beginSet = temp;step++;}return 0;}
import java.util.Hashtable;public class LRUCache{class DLinkedNode{int key;int value;DLinkedNode pre;DLinkedNode post;}private void addNode(DLinkedNode node){node.pre = head;node.post = head.post;head.post.pre = node;head.post = node;}private void removeNode(DLinkedNode node){DLinkedNode pre = node.pre;DLinkedNode post = node.post;pre.post = post;post.pre = pre;}private void moveToHead(DLinkedNode node){this.removeNode(node);this.addNode(node);}private DLinkedNode popTail(){DLinkedNode res = tail.pre;this.removeNode(res);return res;}private Hashtable<Integer, DLinkedNode> cache = new Hashtable<Integer, DLinkedNode>();private int count;private int capacity;private DLinkedNode head, tail;public LRUCache(int capacity){this.count = 0;this.capacity = capacity;head = new DLinkedNode();head.pre = null;tail = new DLinkedNode();tail.post = null;head.post = tail;tail.pre = head;}public int get(int key){DLinkedNode node = cache.get(key);if(node == null){return -1;}this.moveToHead(node);return node.value;}public void put(int key, int value){DLinkedNode node = cache.get(key);if(node == null){DLinkedNode newNode = new DLinkedNode();newNode.key = key;newNode.value = value;this.cache.put(key, newNode);this.addNode(newNode);++count;if(count > capacity){DLinkedNode tail = this.popTail();this.cache.remove(tail.key);--count;}}else{node.value = value;this.moveToHead(node);}}}
