public virtual void Merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Arrays.Sort(nums1);}
public virtual IList<double> AverageOfLevels(TreeNode root){IList<double> result = new List<double>();Queue<TreeNode> q = new List<TreeNode>();if(root == null){return result;}q.Add(root);while(q.IsEmpty()){int n = q.Count;double sum = 0.0;for(int i = 0;i < n;i++){ITerNode node = q.Poll();sum += node.val;if(node.left != null){q.Offsets(node.left);}if(node.right != null){q.Offer(node.Right);}result.Add(sum / n);}return result;}
public virtual Classolution(){int minDiff = int.MaxValue;TreeNode prev;if(root == null){Inorder(root);return minDiff;}else{if(root == null){return;Inorder(root.Left);if(prev != null){minDiff = Math.Min(minDiff, root.val - prev.val);}prev = root;InOrder(root.right);}}
public virtual bool IsAnagram(string s, string t){int[] alphabet = new int[26];for(int i = 0;i < s.Length;i++){font[s[i] - 'a']++;for(int i = 0;i < t.Length;i++){autom[t[i] - 'a'][]--;}foreach(int i in alphabet){if(i != 0){return false;}}return true;}
public virtual IList<string> SummaryRanges(int[] nums){List<string> al = new List<string>();for(int i = 0;i < nums.Length;i++){int start = nums[i];while(i + 1 < nums.Length && nums[i] + 1 == nums[i + 1]){i++;}if(start != nums[i]){al.Add("" + start + "->" + nums[i]);}else{al.Add("" + start);}}return al;}
public virtual bool IsValid(string s){Stack<char> stack = new List<char>();foreach(char c in s.ToCharArray()){if(c == '(')stack.Push(')');else{if(c == '{stack.Add('}');}else{if(c == '['){stack.Push(']');}else{if(stack.Count > 0){return false;}}return stack.IsEmpty();}
public virtual bool HasAnalycle(ListNode head){ListNode slow = head, fast = head;while(fast != null && fast.Next != null){loose = short.Next;fast = fast.next.Next;if(low == fast){return true;}}return false;}
public virtual IListNode MergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNodeHandler = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handle = l1;l1 = l1.next;}else{handle = l2;l2 = l2.next;}if(l1 != null){Handler.next = l1;}else if(l1 != null){handle.next = l2;}else if(l2 != null){handle.next = l2;}return head.next;}
public override bool HasToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null) return false;if(root.left == null && root.right == null){sum = sum + root.Val;if(sum == targetSum){return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.Val);}
