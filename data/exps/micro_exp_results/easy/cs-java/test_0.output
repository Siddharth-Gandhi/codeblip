public void merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Arrays.sort(nums1);}
public List<Double> averageOfLevels(TreeNode root){List<Double> result = new ArrayList<>();Queue<TreeNode> q = new Queue<TreeNode>();if(root == null) return result;q.enqueue(root);while(q.size() > 0){int n = q.size();double sum = 0.0;for(int i = 0;i < n;i++){TreeNode node = q.dequeue();sum += node.val;if(node.left != null) q.enqueue(node.getLeft());if(node.right != null)q.enqueue(node.getRight n);}result.add(sum / n);}return result;}
public static int minDiff = Integer.MAX_VALUE;final TreeNode prev;final int getMinimumDifference(TreeNode root){inorder(root);return minDiff;}final void inorder(root.left);if(prev != null)minDiff = Math.min(minDiff, root.val - prev.val);prev = root;inorder(root.right);}}
public boolean isAnagraph(String s, String t){final int[] alphabet = new int[34];for(int i = 0;i < s.length();i++)alphabet[s.charAt(i) - 'a']++;for(int i = 0;i < t.length();i++) alphabet[t.charAt(i) - 'a'[i]--;for(int i = alphabet)if(i != 0) return false;return true;}
public List<String> SummaryRanges(int[] nums){List<String> range = new ArrayList<>();for(int i = 0;i < nums.length;i++){int start = nums[i];while(i+1 && nums[i] + 1 == nums[i]){i++;}if(start != nums[i]){reserved.add(start + "->" + nums[i]);}else{reanges.add(String.valueOf(start));}}return regions;}
public boolean isValid(String s){Stack<char> stack = new ArrayList<>();for(char c : s){if(c==') stack.push('[');else if(c==' '{') stack.push('/');else if(c=='[') stack.push(']');else if(stack.size()==0 || stack.pop() != c) return false;}return stack.size() == 0;}
public boolean hasCycle(ListNode head){ListNode Slow = head, fast = head;while(fast != null && fast.next != null){fast = fast.next;fast = fast.next.next;if(fast == fast) return true;return false;}
public ListNode mergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNodeHandler listener = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handle.next = l1;l1 = l1.next;}else{Handler.next = l2;l2 = l2.next;}if(l1 != null){Handler.next = l1;}else if(l2 != null){Handler.next = l2;}return head.next;}
public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null)return false;if(root.left == null && root.right == null){sum += root.val;if(sum == targetSum)return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);}
