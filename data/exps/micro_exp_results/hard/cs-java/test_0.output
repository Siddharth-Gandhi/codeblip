public int maxProfit(int k, int[] values){int n = specs.length;if(n <= 1){return 0;}if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(props[i] > specs[i] - 1]) maxPro += prices[i] - 1];}return maxPro;}int[] dp = new int[k + 1, n];for(int i = 1;i <= k;i++){int localMax = dp[i - 1, 0] - prices[i];for(int j = 1;i < n;j++){int i = dp[i - 1], points[j] + localMax);localMax = Math.max(localMax, dp[i - 1, j] - holidays[j]);}}return dp[k, n - 1];}
public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){List<Integer> projects = new ArrayList<>();for(int i = 0;i < Profits.length;i++){pProjections.add((short[i],Profits[i]));}pProjects = positions.toArray(pow[i], Profits[i]));List<Integer> availableProjects = new ArrayList<>(p.sizeByPrefix).toList();int index = 0;for(int i = 0;i < k;i++){while(index < commits.size() && does[index].get Capital();}if(!availableProjects.isEmpty())break;] maxProfitProjects.add(p);}return W;}
public List<String> findWords(char[][] big, String[] words, String[] words){List<String> res = new ArrayList<>();TrieNode root = buildTrie(words);for(int i = 0;i <board.length;i++){for(int j = 0;j < brow.length;j++){dfs(board, i, j, root, res);}return res;}final void dfs(a, i, j, root, res);}
public int calculate(String s){Stack<Integer> stack = newStack<Integer>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.length();i++){char c = s.charAt(i);if(char.isDigit(c)){number = 10 * number +(c - '0');}else if(c == '['){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '){result += sign * number;number = 0;result *= stack.pop();}}if(number != 0){result += sign * number;return result;}
public List<TreeNode> TopSort(TreeNode root){LinkedList<TreeNode> result = new LinkedList<TreeNode>();if(root != null){LinkedList<TreeNode> stack = new LinkedList<TreeNode>();Stack.addFirst(root);while(stack.size() > 0){TreeNode curr = stack.getFirst().getValue();result.addFirst(curr);if(curr.right != null) stack.addFirst(curr.right);if(curr.left != null) stack.addFirst(curr.left);}}return result;}
public int maxPathSum(TreeNode root){int result = Integer.MIN_VALUE;Map<TreeNode, Integer> maxRootPath = new HashMap<>();maxRootPath[null] = 0;for(TreeNode node : TopSort(root)){int left = Math.max(maxRootPath.getValueOrDefault(node.left, 0), 0);int right = Math.max(maxRootPath.getValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.max(left, right) + node.val;result = Math.max(left + right + node.val, result);}return result;}
