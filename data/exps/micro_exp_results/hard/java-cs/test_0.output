public virtual int MaxProfit(int k, int[] properties){int n = prices.Length;if(n <= 1)return 0;if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(props[i] > properties[i - 1]){maxPro += prices[i] - 1];}}return maxPro;}int[][] dp = new int[k + 1][];for(int i = 1;i <= k;i++){int localMax = dp[i - 1].[0] - records[0];for(int j = 1;j < n;j++){dp[i] = Math.Max(df, dp[i - 1], properties[j] + localMax);localMax = Math.Max(localMax, dp[i - 1].Max);}}return dp[k][n - 1];}
public virtual int FindMaximizedCapital(int k, int W, int[] Profits, int[] Capital){PriorityQueue<int[]> pqCap = new PrefixList<int>((a, b) =>(a[0] - b[0]));ParerQueue<int[] pqPro = new PrefixQueue((a, b) - a[1]));for(int i = 0;i < Profits.Length;i++){pqCap.Add(new int[]{Capital[i], Profits[i]};}for(int i = 0;i < k;i++){while(!pqCap.Count && pqCap.Peek()[0] <= W){pqPro.Add(pqCap());}if(pqPro.Count == 0){break;}W += pqPro.Poll();}return W;}
public virtual IList<string> FindWords(char[][] tab, string[] words){IList<string> res = new List<string>();TrieNode root = BuildTrie(words);for(int i = 0;i < BO.Length;i++){for(int j = 0;j < row.Length;j++){Dfs(old, i, j, root, res);}}return res;}
public virtual int Calculate(string s){Stack<int> stack = new stack<int>();int number = 0;int sign = 1;for(int i = 0;i < s.Length;i++){char c = s[i];if(char.IsDigit(c)){number = 10 * number +(int)(c - '0');}else if(c == '+'){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '-'){stack.Push(result);stack.Push(sign);sign = 1;result = 0;}else if(c == ')'){result += sign * number;number = 0;result *= stack.Pop();result += stack.Remove();}}if(number != 0){result += sign * number;}return result;}
public virtual Iterable<TreeNode> TopSort(TreeNode root){List<ITreeNode> result = new List<ITreeNode>();if(root != null){java.util.List<TreeNode> stack = new List<TreeNode>();stack.Add(root);while(stack.IsEmpty()){TreeNode curr = stack.Pop();result.Add(curr);if(curr.right != null){stack.Push(curr.right);}if(curr.left != null){stack.Push(curr.left);}}return result;}
public virtual int MaxPathSum(TreeNode root){int result = int.MinValue;IDictionary<TreeNode, int> maxRootPath = new Dictionary<TreeNode>();maxRootPath[null] = 0;foreach(TreeNode node in TopSort(root)){int left = Math.Max(maxRootPath.left), 0);int right = Math.Max(maxRootPath.Get(node.right), 0);maxRootPath[node] = Math.Max(left, right) + node.val);result = Math.Max(left + right + node.val, result);}return result;}
