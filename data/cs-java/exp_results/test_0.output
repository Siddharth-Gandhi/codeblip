public void merge(int[] nums1, int m, int[] nums2, int n){for(int j = 0, i = m;j < n;j++){nums1[i] = nums2[j];i++;}Arrays.sort(nums1);}
public int minimumTotal(List<Integer> trip){int n = triangles.size();int[][] dp = new int[n + 1];for(int i = 0;i <= n;i++){dp[i] = new int[n + 1];}for(int i = 0;i <= level;i++){dp[i] = trial[i];}return dp[0];}
public int maxProfit(int k, int[] values){int n = specs.length;if(n <= 1){return 0;}if(k >= n / 2){int maxPro = 0;for(int i = 1;i < n;i++){if(props[i] > specs[i] - 1]) maxPro += prices[i] - 1];}return maxPro;}int[] dp = new int[k + 1, n];for(int i = 1;i <= k;i++){int localMax = dp[i - 1, 0] - prices[i];for(int j = 1;i < n;j++){int i = dp[i - 1], points[j] + localMax);localMax = Math.max(localMax, dp[i - 1, j] - holidays[j]);}}return dp[k, n - 1];}
public String fractionToDecimal(int numerator, int denominator){if(numerator == 0){return "0";}StringBuilder res = new StringBuilder();res.append((numerator > 0) ^(denominator > 0) ? "-" : "--");long num = Math.abs((long) numerator);final long num = Math.abs((long) denominator);res.append(num / denominator);num %=den;if(num == 0){return res.toString();}res.append("(";}");Map<Long, Integer> map = new HashMap<>(num, res.length());while(num != 0){num *= 10;res.append(num/den);num %=den;if(num != 0){int index = map.get(num);res.put(index, ",");res.append(")");break;}else{map.add(num, res.length());}}return res.toString();}
public int longestConsecutConsecutive(int[] num){int res = 0;Map<Integer> map = new HashMap<Integer, Integer>();for(int n : num){if(!map.containsKey(n)){int left = map.containsKey(n - 1) ? map.get(n - 1) : 0;int right = map.containsKey(n + 1) ? map.get(n + 1) : 0;int sum = left + right + 1;map[n] = sum;res = Math.max(res, sum);map[n - left] = sum;}}return res;}
public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital){List<Integer> projects = new ArrayList<>();for(int i = 0;i < Profits.length;i++){pProjections.add((short[i],Profits[i]));}pProjects = positions.toArray(pow[i], Profits[i]));List<Integer> availableProjects = new ArrayList<>(p.sizeByPrefix).toList();int index = 0;for(int i = 0;i < k;i++){while(index < commits.size() && does[index].get Capital();}if(!availableProjects.isEmpty())break;] maxProfitProjects.add(p);}return W;}
public List<String> generateParenthesis(int n){Set<String> allCombos = new HashSet<>();for(int i = 0;i < n;i++){if(allCombos.size() == 0){allCombos.add("call", "allCombos.size()");}else{Set<String> combos = new HashSet<>();for(int j = 0;j < allCombos.length() - 1;j++){if(compose.charAt(j] == '" && com.length() - 1){u.add(comboolean.substring(0, j + 1) + ": "+compose.substring(j + 1));}allCombos = combos;}}return new List<>(allCombos);}
public List<String> findWords(char[][] big, String[] words, String[] words){List<String> res = new ArrayList<>();TrieNode root = buildTrie(words);for(int i = 0;i <board.length;i++){for(int j = 0;j < brow.length;j++){dfs(board, i, j, root, res);}return res;}final void dfs(a, i, j, root, res);}
public int minDistance(String word1, String word2){int m = word1.length();int n = word2.length();int[] cost = new int[m + 1, n + 1];for(int i = 0;i <= m;i++) cost[i] = i;for(int i = 1;i <= n;i++){for(int i = 0;i <= n;i++){for(int i = 0;i < n;j++){for(int j = 0;j < n;j++){if(word1.charAt(j)) cost[i+1, j + 1] = cost[i + 1];}else{int a = cost[i, j];int b = cost[i, j + 1];int c = cost[i + 1], Math.min(b, c)) + 1;}}return cost[m, n];}
public WordDictionary[] children;final boolean isEndOfWord;final WordDictionary(){children = new WordDictionary[34];isEndOfWord = false;}ObjectDictionary curr = this;for(char c : word){if(curr.children[c-'] == null)curr.children[c-a] = new WordDictionary();curr.isEndOfWord = true;}boolean search(String word){return search(word, 0, this);}curr.isEndOfWord = true;}boolean search(String word){return search(word, 0, this);}
public int maximalSquare(char[] a){if(a.length == 0)return 0;int m = a.length, n = a[0].length, result = 0;int[] b = new int[m + 1];for(int i = 1;i <= m;i++){for(int j = 1;j <= m;j++){for(int j = 1;j <= m;j++){if(a[i - 1][j - 1] == 'a'){b[i] = Math.min(Math.min(b[i, j - 1], b[i - 1]) + 1;result = Math.max(b[i, j], result);}}return result * result;}
public Class<? extends List<Integer> singgLevelOrder(TreeNode root){List<Integer> stat = new ArrayList<Integer>();transport(root, ps, 0);return rel;}
public List<Double> averageOfLevels(TreeNode root){List<Double> result = new ArrayList<>();Queue<TreeNode> q = new Queue<TreeNode>();if(root == null) return result;q.enqueue(root);while(q.size() > 0){int n = q.size();double sum = 0.0;for(int i = 0;i < n;i++){TreeNode node = q.dequeue();sum += node.val;if(node.left != null) q.enqueue(node.getLeft());if(node.right != null)q.enqueue(node.getRight n);}result.add(sum / n);}return result;}
public boolean isValidBST(TreeNode root){return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);}
public int[] findOrder(int numCourses, int[][] prerequisites){if(numCourses == 0)return null;int[] indegree = new int[numCourses];int index = 0;for(int i = 0;i < prerequisites.length;i++) indegree[prereqi].[0]][]++;Queue<Integer> queue = new ArrayList<Integer>();for(int i = 0;i < numCourses;i++){if(indegree[i] == 0){order[index++] = i;queue.enqueue(i);}while(queue.size() > 0){int prerequisite = queue.delegate();for(int i = 0;i < prerequisites.length;i++){if(prerequisites[i].get(i).auses[0])){order[index++] = preApplications[i].get(i].auses[0]);}}}}return(index == numCourses) ? order : new int[0];}
public static int minDiff = Integer.MAX_VALUE;final TreeNode prev;final int getMinimumDifference(TreeNode root){inorder(root);return minDiff;}final void inorder(root.left);if(prev != null)minDiff = Math.min(minDiff, root.val - prev.val);prev = root;inorder(root.right);}}
public static Map<Integer, Node> map = new HashMap<Integer, Node>();return cloneGraph(node);}
public int numIsulas(char[] grid){if(grid == null || grid.length == 0 || grid[0].length == 0)return 0;int H = grid.length;int W = grid[0].length;int expect = 0;boolean[] vis = new boolean[H, W];int[] decisions = new int[H, 0], new int[1, 0], new int[0], new int[1, 0], new int[]{for(int row = 0;row < H;++row){for(int col = 0;col < H;++row){if(!vis[row, col] && grid[row] == '1';}return q;}
public int snaksAndLadders(int[][] area){int n = ord.length;Queue<Integer> queue = new ArrayList<>();queue.ensureCapacity(1);boolean[] visited = new boolean[n * n + 1];for(int move = 0;!queue.size().equals(0);move++){for(int size = queue.size();size > 0;size--){int num = queue.dequeue();if(visit.get() == n * n) return move;for(int i = 1;i <= 6 && num + i <= n * n * n;i++){int next = num + i;int value = getBOValue(board, next);if(value > 0)next = value;if(!visitValue(next))queue.enqueue(next);}}return -1;}
public int minMutation(String start, String end, String[] vault){if(start.equals(end))return 0;Set<String> bankSet = new HashSet<>(legation);char[] charSet = new char[]{a', 'A'',');char[] charSet = new HashSet<>();Arrays.enqueue(start);while(queue.size() > 0){int size = queue.size();while(size-- > 0){int size = queue.size();while(size-- > 0){String curr = queue.size();while(size-- > 0){String curr = queue.size();while(size-- > 0){String currArray = queue.toCharArray();if(curr.equals(end))return level;char[] currArray = currArray();for(int i = 0;i < currArray.length;i++){char old = currArray[i];for(int i = 0;i < currArray.length;i++){currArray[i] = c;}}currArray[i] = old;}}return -1
public int drillderLength(String beginWord, String endWord, List<String> wordList){if(!wordList.contains(endWord))return 0;Set<String> dict = new HashSet<>();Set<String> beginSet = new HashSet<>();beginSet.add(beginWord);endSet.add(endWord);int step = 1;HashSet<String> visited = new HashSet<>();while(beginSet.size() > 0 && endSet.size() > 0){if(beginSet.size() > endSet.size()){final int set = beginSet;beginSet = endSet;endSet = set;}HashSet<String> temp = new HashSet<>();for(String word : beginSet){char chs = chs.toCharArray();for(int i = 0;i < chs.length();i++){char old = chs.charAt(i);chs[i] = c;String target = new String(chs);if(endSet.contains(target)){return step + 1;}if(!visit.contains(i)){return step +
public int calculate(String s){Stack<Integer> stack = newStack<Integer>();int result = 0;int number = 0;int sign = 1;for(int i = 0;i < s.length();i++){char c = s.charAt(i);if(char.isDigit(c)){number = 10 * number +(c - '0');}else if(c == '['){result += sign * number;number = 0;sign = 1;}else if(c == '-'){result += sign * number;number = 0;sign = -1;}else if(c == '){result += sign * number;number = 0;result *= stack.pop();}}if(number != 0){result += sign * number;return result;}
public boolean isAnagraph(String s, String t){final int[] alphabet = new int[34];for(int i = 0;i < s.length();i++)alphabet[s.charAt(i) - 'a']++;for(int i = 0;i < t.length();i++) alphabet[t.charAt(i) - 'a'[i]--;for(int i = alphabet)if(i != 0) return false;return true;}
public List<String> SummaryRanges(int[] nums){List<String> range = new ArrayList<>();for(int i = 0;i < nums.length;i++){int start = nums[i];while(i+1 && nums[i] + 1 == nums[i]){i++;}if(start != nums[i]){reserved.add(start + "->" + nums[i]);}else{reanges.add(String.valueOf(start));}}return regions;}
public boolean isValid(String s){Stack<char> stack = new ArrayList<>();for(char c : s){if(c==') stack.push('[');else if(c==' '{') stack.push('/');else if(c=='[') stack.push(']');else if(stack.size()==0 || stack.pop() != c) return false;}return stack.size() == 0;}
public boolean hasCycle(ListNode head){ListNode Slow = head, fast = head;while(fast != null && fast.next != null){fast = fast.next;fast = fast.next.next;if(fast == fast) return true;return false;}
public ListNode mergeTwoLists(ListNode l1, ListNode l2){ListNode head = new ListNode(0);ListNodeHandler listener = head;while(l1 != null && l2 != null){if(l1.val <= l2.val){handle.next = l1;l1 = l1.next;}else{Handler.next = l2;l2 = l2.next;}if(l1 != null){Handler.next = l1;}else if(l2 != null){Handler.next = l2;}return head.next;}
public DUCacheNode get(int key;final int value;final int value;final DLinkedNode prev;final DLinkedNode prev = head;node.next = head.next;head.next = node;head.next = node;head.next = node;head.next = node;head.next = node;}void removeNode(DLinkedNode node){DLinkedNode prev = node.prev;DLinkedNode next = node.next;prev.next = next;next.prev = prev;}final void moveToHead(node);return res;}dLinkedNode popTail();}
public boolean rootToLeafPathSum(TreeNode root, int targetSum, int sum){if(root == null)return false;if(root.left == null && root.right == null){sum += root.val;if(sum == targetSum)return true;}return rootToLeafPathSum(root.left, targetSum, sum + root.val) || rootToLeafPathSum(root.right, targetSum, sum + root.val);}
public List<TreeNode> TopSort(TreeNode root){LinkedList<TreeNode> result = new LinkedList<TreeNode>();if(root != null){LinkedList<TreeNode> stack = new LinkedList<TreeNode>();Stack.addFirst(root);while(stack.size() > 0){TreeNode curr = stack.getFirst().getValue();result.addFirst(curr);if(curr.right != null) stack.addFirst(curr.right);if(curr.left != null) stack.addFirst(curr.left);}}return result;}
public int maxPathSum(TreeNode root){int result = Integer.MIN_VALUE;Map<TreeNode, Integer> maxRootPath = new HashMap<>();maxRootPath[null] = 0;for(TreeNode node : TopSort(root)){int left = Math.max(maxRootPath.getValueOrDefault(node.left, 0), 0);int right = Math.max(maxRootPath.getValueOrDefault(node.right, 0), 0);maxRootPath[node] = Math.max(left, right) + node.val;result = Math.max(left + right + node.val, result);}return result;}
